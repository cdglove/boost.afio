[/============================================================================
  Boost.AFIO

  Use, modification and distribution is subject to the Boost Software License,
  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt)
=============================================================================/]


[/ Generated by doxygen_xml2qbk 1.1.1, don't change, will be overwritten automatically]
[/ Generated from doxy/doxygen_output/xml/group__async__io__handle____ops.xml]
[section:path path]

'''<indexterm><primary>path</primary></indexterm>'''
Returns the path of this i/o handle right now if the handle is open and ['refresh] is true, else last known good. May be null if the file has been deleted. 

[heading Description]
Note the refreshed path completely dereferences any intermediate symbolic links to return a truly absolute canonical path, and therefore may look quite different to before. Some operating systems unfortunately also return any one of the hard links to the file, so if hard links is greater than one the path refreshed will randomly permute.

Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage. 

[heading Synopsis]
``virtual path async_io_handle::path(bool refresh = false)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[bool] [] [refresh] [Whether to ask the OS for the current path of this handle.]]
]


[heading Returns]
The path of this i/o handle right now. 

[heading Header]
`#include <boost/afio/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD..Paths are only refreshed for directories, not files.]
[raceguarantee Linux, Windows..Paths are always refreshed and ignore other hard links.]
[raceguarantee OS X..Paths are only refreshed for directories and files with a single hard link.]
 ]


[endsect]

[section:direntry direntry]

'''<indexterm><primary>direntry</primary></indexterm>'''
Returns a mostly filled directory\u005fentry for the file or directory referenced by this handle. Use [^`metadata_flags::All`] if you want it as complete as your platform allows, even at the cost of severe performance loss. 

[heading Synopsis]
``virtual directory_entry async_io_handle::direntry(metadata_flags wanted = directory_entry::metadata_fastpath())``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[metadata_flags] [] [wanted] [The metadata wanted.]]
]


[heading Returns]
A directory entry for this handle. 

[heading Header]
`#include <boost/afio/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD..Race free if handle open for directories and regular files only, else if handle closed or a symlink race free up to the containing directory. All metadata is fetched in a single shot.]
[raceguarantee Linux..Race free if handle open, else if handle closed race free up to the containing directory. All metadata is fetched in a single shot.]
[raceguarantee OS X..Race free if handle open for directories and regular files only. No guarantees if handle closed or a symlink.]
[raceguarantee Windows..Handle must be open and is always race free. Metadata may be fetched in a single shot if at least two categories requested, or else the following categories apply: (i) ino (ii) type, atim, mtim, ctim, birthtim, sparse, compressed (iii) nlink, size, allocated, blocks.]
 ]


[endsect]

[section:target target]

'''<indexterm><primary>target</primary></indexterm>'''
Returns the target path of this handle if it is a symbolic link. 

[heading Description]
Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage. 

[heading Synopsis]
``virtual path async_io_handle::target()``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
]


[heading Returns]
The path the symbolic link points to. May not exist or even be valid.

[heading Header]
`#include <boost/afio/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD..Race free up to the containing directory.]
[raceguarantee Linux, Windows..Race free if handle open, else up to the containing directory.]
[raceguarantee OS X..No guarantees.]
 ]


[endsect]

[section:link link]

'''<indexterm><primary>link</primary></indexterm>'''
Hard links the file to a new location on the same volume. 

[heading Description]
If you wish to make a temporary file whose contents are ready appear at a location and error out if a file entry is already there, use link() and if success, unlink() on the former location. If you wish to always overwrite the destination, use atomic\u005frelink() instead.

On Windows, the destination directory cannot have any handle opened to it with delete/rename privileges ([^`file_flags::Write`]) anywhere in the system. This is an operating system limitation.

Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage. 

[heading Synopsis]
``virtual void async_io_handle::link(const async_path_op_req & req)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[const async_path_op_req &] [] [req] [The absolute or relative (in which case precondition specifies a directory) path to create a hard link at.]]
]


[heading Header]
`#include <boost/afio/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD..Race free up to the containing directory for both source and target.]
[raceguarantee Linux, Windows..Race free for source if handle open, else up to the containing directory. Race free up to the target directory.]
[raceguarantee OS X..No guarantees.]
 ]


[endsect]

[section:unlink unlink]

'''<indexterm><primary>unlink</primary></indexterm>'''
Unlinks the file from its present location as determined by path(true), which could be any hard link on those operating systems with an unstable path(true). Other links may remain to the same file. 

[heading Description]
On Microsoft Windows, this routine unlinks items as follows:

The reason for such complexity is that this algorithm, if it renames successfully, neatly works around a number of annoying features in Windows, specifically that when you delete a file you actually don't delete it till an unknown amount of time later. This breaks code which tries to delete a directory tree, and finds that the directories won't delete because they still contain files supposedly deleted but actually not quite yet. By renaming the items as far away as possible, this problem ought to go away - unless of course that the user does not have permissions to write into any directory other than the one being eventually deleted, in which case you will still see the strange access denied and directory not empty errors from before.

Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage.

[heading Synopsis]
``virtual void async_io_handle::unlink()``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
]


[heading Header]
`#include <boost/afio/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux..Race free up to the containing directory.]
[raceguarantee Windows..Race free if handle open, else up to the containing directory.]
[raceguarantee OS X..No guarantees.]
 ]


[endsect]

[section:atomic_relink atomic_relink]

'''<indexterm><primary>atomic_relink</primary></indexterm>'''
Links the file to a new location and unlinks the file from its present location as determined by path(true), ['atomically overwriting any file entry at the new location]. Very useful for preparing file content elsewhere and once ready, atomically making it visible at some named location to other processes. Note that operating systems with an unstable path(true) may relink any hard link to the file to the new location. 

[heading Description]
Note that not all filing systems guarantee the atomicity of the relink itself (i.e. the file may appear at two locations in the filing system for a period of time), though all supported platforms do guarantee the atomicity of the replaced location i.e. the location you are relinking to will always refer to some valid file to all readers, and will never be deleted or missing. Some filing systems may also fail to do the unlink if power is lost close to the relinking operation.

On Windows, the destination directory cannot have any handle opened to it with delete/rename privileges ([^`file_flags::Write`]) anywhere in the system. This is an operating system limitation.

Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by [^`afio::path`] in NT kernel namespace paths. [^`normalise_path()`] can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage. 

[heading Synopsis]
``virtual void async_io_handle::atomic_relink(const async_path_op_req & req)``

[heading Parameters]

[table
[[Type] [Concept] [Name] [Description] ]
[[const async_path_op_req &] [] [req] [The absolute or relative (in which case precondition specifies a directory) path to relink to.]]
]


[heading Header]
`#include <boost/afio/afio.hpp>`

[heading Race Guarantees][raceguarantees 
[raceguarantee FreeBSD, Linux..Race free up to the containing directory for both source and target.]
[raceguarantee OS X..No guarantees.]
[raceguarantee Windows..Race free for source if handle open, else up to the containing directory. Race free up to the target directory.]
 ]


[endsect]

