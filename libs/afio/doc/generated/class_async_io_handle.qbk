[/============================================================================
  Boost.AFIO

  Use, modification and distribution is subject to the Boost Software License,
  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt)
=============================================================================/]


[/ Generated by doxygen_xml2qbk 1.1.1, don't change, will be overwritten automatically]
[/ Generated from doxy/doxygen_output/xml/classboost_1_1afio_1_1async__io__handle.xml]
[section:async_io_handle async_io_handle]
[section:open_states open_states]

'''<indexterm><primary>open_states</primary></indexterm>'''
'''<indexterm><primary>closed</primary></indexterm>'''
'''<indexterm><primary>open</primary></indexterm>'''
'''<indexterm><primary>opendir</primary></indexterm>'''
In which way this handle is opened or not. 

[heading Synopsis]
``enum open_states {closed, open, opendir};``

[heading Values]

[table
[[Value] [Description] ]
[[closed] [This handle is closed. ]]
[[open] [This handle is open as a normal handle. ]]
[[opendir] [This handle is open as a cached directory handle, and therefore closing it explicitly has no effect. ]]
]


[heading Header]
`#include <boost/afio/afio.hpp>`


[endsect]


'''<indexterm><primary>async_io_handle</primary></indexterm>'''
The abstract base class encapsulating a platform-specific file handle. 

[heading Description]
Note that failure to explicitly schedule closing a file handle in the dispatcher means it will be synchronously closed on last reference count by async\u005fio\u005fhandle. This can consume considerable time, especially if SyncOnClose is enabled.

[heading Synopsis]
``class async_io_handle
      : public std::enable_shared_from_this< async_io_handle >
{
  // ...
};
``

[heading Constructor(s)]
[table
[[Function] [Description] [Parameters] ]
[[``~async_io_handle()``

] [] [


]]
]

[heading Member Function(s)]
[table
[[Function] [Description] [Parameters]  [Returns]]
[[``async_file_io_dispatcher_base * parent()``

] [Returns the parent of this io handle. ] [


]]
[[``std::shared_ptr< async_io_handle > container()``

] [Returns a handle to the directory containing this handle. Only works if [^`file_flags::HoldParentOpen`] was specified when this handle was opened. ] [


]]
[[``open_states is_open()``

] [Returns if this handle is opened or not. ] [


]]
[[``void * native_handle()``

] [Returns the native handle of this io handle. On POSIX, you can cast this to a fd using [^`(int)(size_t) ``native_handle()`]. On Windows it's a simple [^`(HANDLE) ``native_handle()`]. ] [


]]
[[``const chrono::system_clock::time_point & opened()``

] [Returns when this handle was opened. ] [


]]
[[``boost::afio::path path(bool refresh = false)``

] [Returns the path of this i/o handle right now if the handle is open and ['refresh] is true, else last known good. May be null if the file has been deleted. ] [[* bool]: ['refresh]:  Whether to ask the OS for the current path of this handle.



][
The path of this i/o handle right now. 


]]
[[``boost::afio::path path()``

] [Returns the last known good path of this i/o handle. May be null if the file has been deleted. ] [


]]
[[``file_flags flags()``

] [Returns the final flags used when this handle was opened. ] [


]]
[[``bool opened_as_file()``

] [True if this handle was opened as a file. ] [


]]
[[``bool opened_as_dir()``

] [True if this handle was opened as a directory. ] [


]]
[[``bool opened_as_symlink()``

] [True if this handle was opened as a symlink. ] [


]]
[[``bool available_to_directory_cache()``

] [True if this handle is used by the directory handle cache (not UniqueDirectoryHandle and is open for write and not open for write) ] [


]]
[[``off_t read_count()``

] [Returns how many bytes have been read since this handle was opened. ] [


]]
[[``off_t write_count()``

] [Returns how many bytes have been written since this handle was opened. ] [


]]
[[``off_t write_count_since_fsync()``

] [Returns how many bytes have been written since this handle was last fsynced. ] [


]]
[[``directory_entry direntry(metadata_flags wanted = directory_entry::metadata_fastpath())``

] [Returns a mostly filled directory_entry for the file or directory referenced by this handle. Use [^`metadata_flags::All`] if you want it as complete as your platform allows, even at the cost of severe performance loss. ] [[* metadata_flags]: ['wanted]:  The metadata wanted.



][
A directory entry for this handle. 


]]
[[``stat_t lstat(metadata_flags wanted = directory_entry::metadata_fastpath())``

] [Returns a mostly filled stat_t structure for the file or directory referenced by this handle. Use [^`metadata_flags::All`] if you want it as complete as your platform allows, even at the cost of severe performance loss. Calls direntry(), so same race guarantees as that call. ] [[* metadata_flags]: ['wanted]:  




]]
[[``boost::afio::path target()``

] [Returns the target path of this handle if it is a symbolic link. ] [

][
The path the symbolic link points to. May not exist or even be valid.


]]
[[``void * try_mapfile()``

] [Tries to map the file into memory. Currently only works if handle is read-only. ] [


]]
[[``void link(const async_path_op_req & req)``

] [Hard links the file to a new location on the same volume. ] [[* const async_path_op_req &]: ['req]:  The absolute or relative (in which case precondition specifies a directory) path to create a hard link at.




]]
[[``void unlink()``

] [Unlinks the file from its present location as determined by path(true), which could be any hard link on those operating systems with an unstable path(true). Other links may remain to the same file. ] [


]]
[[``void atomic_relink(const async_path_op_req & req)``

] [Links the file to a new location and unlinks the file from its present location as determined by path(true), ['atomically overwriting any file entry at the new location]. Very useful for preparing file content elsewhere and once ready, atomically making it visible at some named location to other processes. Note that operating systems with an unstable path(true) may relink any hard link to the file to the new location. ] [[* const async_path_op_req &]: ['req]:  The absolute or relative (in which case precondition specifies a directory) path to relink to.




]]
]

[heading Header]
`#include <boost/afio/afio.hpp>`

[include generated/group_async_io_handle__ops.qbk]

[endsect]

