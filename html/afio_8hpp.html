<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Boost.AFIO</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head>

<table cellpadding="2" width="100%">
<tbody>
<tr>
<td valign="top">
<img alt="Boost.AFIO" src="images/ggl-logo-big.png" height="80" width="200">
&nbsp;&nbsp;
</td>
<td valign="top" align="right">
<a href="http://www.boost.org">
<img alt="Boost C++ Libraries" src="images/accepted_by_boost.png" height="80" width="230" border="0">
</a>
</td>
</tr>
</tbody>
</table>
<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Provides a batch asynchronous file i/o implementation based on Boost.ASIO.  
<a href="#details">More...</a></p>

<p><a href="afio_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1detail_1_1enqueued__task__impl.html">boost::afio::detail::enqueued_task_impl&lt; R &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1enqueued__task__impl_1_1_private.html">boost::afio::detail::enqueued_task_impl&lt; R &gt;::Private</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1enqueued__task_3_01_r_07_08_4.html">boost::afio::enqueued_task&lt; R()&gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1enqueued__task_3_01void_07_08_4.html">boost::afio::enqueued_task&lt; void()&gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1thread__source.html">boost::afio::thread_source</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for a source of thread workers.  <a href="classboost_1_1afio_1_1thread__source.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1std__thread__pool.html">boost::afio::std_thread_pool</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A very simple thread pool based on std::thread or boost::thread.  <a href="classboost_1_1afio_1_1std__thread__pool.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>boost::afio::std_thread_pool::worker</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1path.html">boost::afio::path</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An AFIO filesystem path, a thin wrapper of filesystem::path used to mark when a filesystem path has been prepared for AFIO usage. Note that on Windows this exclusively refers to a case sensitive NT kernel path, not a Win32 path (Win32 paths are converted in the constructor).  <a href="classboost_1_1afio_1_1path.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>boost::afio::path::direct</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1path_1_1make__absolute.html">boost::afio::path::make_absolute</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a path absolute according to the current working directory.  <a href="structboost_1_1afio_1_1path_1_1make__absolute.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1path__hash.html">boost::afio::path_hash</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A hasher for path.  <a href="structboost_1_1afio_1_1path__hash.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1stat__t.html">boost::afio::stat_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Metadata about a directory entry.  <a href="structboost_1_1afio_1_1stat__t.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1statfs__t.html">boost::afio::statfs_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Metadata about a filing system. Unsupported entries are -1.  <a href="structboost_1_1afio_1_1statfs__t.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1statfs__t_1_1f__flags__t.html">boost::afio::statfs_t::f_flags_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1directory__entry.html">boost::afio::directory_entry</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The abstract base class for an entry in a directory with lazily filled metadata.  <a href="classboost_1_1afio_1_1directory__entry.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1directory__entry__hash.html">boost::afio::directory_entry_hash</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A hasher for <a class="el" href="classboost_1_1afio_1_1directory__entry.html" title="The abstract base class for an entry in a directory with lazily filled metadata.">directory_entry</a>, hashing inode and birth time (if available on this platform).  <a href="structboost_1_1afio_1_1directory__entry__hash.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1async__io__handle.html">boost::afio::async_io_handle</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The abstract base class encapsulating a platform-specific file handle.  <a href="classboost_1_1afio_1_1async__io__handle.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1async__io__op.html">boost::afio::async_io_op</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference to an asynchronous operation.  <a href="structboost_1_1afio_1_1async__io__op.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1vs2013__variadic__overload__resolution__workaround.html">boost::afio::detail::vs2013_variadic_overload_resolution_workaround&lt; C, Args &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1async__file__io__dispatcher__base.html">boost::afio::async_file_io_dispatcher_base</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for dispatching file i/o asynchronously.  <a href="classboost_1_1afio_1_1async__file__io__dispatcher__base.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1when__all__state.html">boost::afio::detail::when_all_state</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1when__any__state.html">boost::afio::detail::when_any_state</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1select__when__ops__return__type.html">boost::afio::detail::select_when_ops_return_type&lt; is_all &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1select__when__ops__return__type_3_01false_01_4.html">boost::afio::detail::select_when_ops_return_type&lt; false &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1enable__if__async__op.html">boost::afio::detail::enable_if_async_op&lt; is_all, T &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1enable__if__async__op_3_01is__all_00_01async__io__op_01_4.html">boost::afio::detail::enable_if_async_op&lt; is_all, async_io_op &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1async__path__op__req.html">boost::afio::async_path_op_req</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience bundle of path and flags, with optional precondition. Paths may be a path fragment (relative to the precondition) or absolute, in which case if necessary they are made canonical and absolute in the constructor according to the current working directory.  <a href="structboost_1_1afio_1_1async__path__op__req.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1async__path__op__req_1_1relative.html">boost::afio::async_path_op_req::relative</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience tag type constructing a relative path <a class="el" href="structboost_1_1afio_1_1async__path__op__req.html" title="A convenience bundle of path and flags, with optional precondition. Paths may be a path fragment (rel...">async_path_op_req</a>.  <a href="structboost_1_1afio_1_1async__path__op__req_1_1relative.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1async__path__op__req_1_1absolute.html">boost::afio::async_path_op_req::absolute</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience tag type constructing an absolute path <a class="el" href="structboost_1_1afio_1_1async__path__op__req.html" title="A convenience bundle of path and flags, with optional precondition. Paths may be a path fragment (rel...">async_path_op_req</a>.  <a href="structboost_1_1afio_1_1async__path__op__req_1_1absolute.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1to__asio__buffers__helper.html">boost::afio::detail::to_asio_buffers_helper&lt; is_const, R, T, is_trivial, is_container &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1to__asio__buffers__helper_3_01is__const_00_01_r_00_01_t_00_01true_00_01false_01_4.html">boost::afio::detail::to_asio_buffers_helper&lt; is_const, R, T, true, false &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1container__to__asio__buffers__helper.html">boost::afio::detail::container_to_asio_buffers_helper&lt; R, C, T, is_const, is_trivial &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1container__to__asio__buffers__helper_3_01_r_00_01std_1_1basic__5b83d962173a868180c70129e7984b44.html">boost::afio::detail::container_to_asio_buffers_helper&lt; R, std::basic_string&lt; C, T, A &gt;, _Ct, is_const, true &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1container__to__asio__buffers__helper_3_01_r_00_01std_1_1vector_08cceb32b20cab5c10bc02eea27ecdef.html">boost::afio::detail::container_to_asio_buffers_helper&lt; R, std::vector&lt; T, A &gt;, _T, is_const, true &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1container__to__asio__buffers__helper_3_01_r_00_01std_1_1array_31d265f3bd056d3edf5412f1bb8b25367.html">boost::afio::detail::container_to_asio_buffers_helper&lt; R, std::array&lt; T, N &gt;, _T, is_const, true &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1to__asio__buffers__helper_3_01is__const_00_01_r_00_01_t_00_01is__trivial_00_01true_01_4.html">boost::afio::detail::to_asio_buffers_helper&lt; is_const, R, T, is_trivial, true &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1to__asio__buffers__helper_3_01is__const_00_01_r_00_01std_1_1vec015c9a1671103d5540a40db22dcf2c1f.html">boost::afio::detail::to_asio_buffers_helper&lt; is_const, R, std::vector&lt; asio::mutable_buffer &gt;, false, true &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1to__asio__buffers__helper_3_01is__const_00_01asio_1_1mutable__ba628783a2410b194f4c8f9901c9e881d.html">boost::afio::detail::to_asio_buffers_helper&lt; is_const, asio::mutable_buffer, std::vector&lt; asio::mutable_buffer &gt;, false, true &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1to__asio__buffers__helper_3_01is__const_00_01_r_00_01std_1_1vecf0033e923d262694df69e5de182cb274.html">boost::afio::detail::to_asio_buffers_helper&lt; is_const, R, std::vector&lt; asio::const_buffer &gt;, false, true &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1to__asio__buffers__helper_3_01is__const_00_01asio_1_1const__bufc343c227ba61700fa8c7433b21830407.html">boost::afio::detail::to_asio_buffers_helper&lt; is_const, asio::const_buffer, std::vector&lt; asio::const_buffer &gt;, false, true &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1to__asio__buffers__helper_3_01is__const_00_01_r_00_01std_1_1arr71ff4d886b752dc4ea6a8a63c5132139.html">boost::afio::detail::to_asio_buffers_helper&lt; is_const, R, std::array&lt; asio::mutable_buffer, N &gt;, false, true &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1to__asio__buffers__helper_3_01is__const_00_01_r_00_01std_1_1arr7698302ecba29743ef4e88d006e0ea0e.html">boost::afio::detail::to_asio_buffers_helper&lt; is_const, R, std::array&lt; asio::const_buffer, N &gt;, false, true &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1detail_1_1async__data__op__req__impl_3_01false_01_4.html">boost::afio::detail::async_data_op_req_impl&lt; false &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1detail_1_1async__data__op__req__impl_3_01true_01_4.html">boost::afio::detail::async_data_op_req_impl&lt; true &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1async__data__op__req.html">boost::afio::async_data_op_req&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience bundle of precondition, data and where for reading into a T as specified by its <a class="el" href="group__to__asio__buffers.html#ga772fe53eebaa2177dc53227bbef03f3f" title="Any trivial type T or STL container.">to_asio_buffers()</a> overload. Data <b>MUST</b> stay around until the operation completes.  <a href="structboost_1_1afio_1_1async__data__op__req.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1async__data__op__req_3_01const_01_t_01_4.html">boost::afio::async_data_op_req&lt; const T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience bundle of precondition, data and where for reading into a T as specified by its <a class="el" href="group__to__asio__buffers.html#ga772fe53eebaa2177dc53227bbef03f3f" title="Any trivial type T or STL container.">to_asio_buffers()</a> overload. Data <b>MUST</b> stay around until the operation completes.  <a href="structboost_1_1afio_1_1async__data__op__req_3_01const_01_t_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1async__data__op__req_3_01void_01_4.html">boost::afio::async_data_op_req&lt; void &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience bundle of precondition, data and where for reading into a T as specified by its <a class="el" href="group__to__asio__buffers.html#ga772fe53eebaa2177dc53227bbef03f3f" title="Any trivial type T or STL container.">to_asio_buffers()</a> overload. Data <b>MUST</b> stay around until the operation completes.  <a href="structboost_1_1afio_1_1async__data__op__req_3_01void_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1async__data__op__req_3_01const_01void_01_4.html">boost::afio::async_data_op_req&lt; const void &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience bundle of precondition, data and where for reading into a T as specified by its <a class="el" href="group__to__asio__buffers.html#ga772fe53eebaa2177dc53227bbef03f3f" title="Any trivial type T or STL container.">to_asio_buffers()</a> overload. Data <b>MUST</b> stay around until the operation completes.  <a href="structboost_1_1afio_1_1async__data__op__req_3_01const_01void_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1make__async__data__op__req.html">boost::afio::detail::make_async_data_op_req&lt; T, is_container &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1make__async__data__op__req_3_01_t_00_01true_01_4.html">boost::afio::detail::make_async_data_op_req&lt; T, true &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1async__enumerate__op__req.html">boost::afio::async_enumerate_op_req</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience bundle of precondition, number of items to enumerate, item pattern match and metadata to prefetch.  <a href="structboost_1_1afio_1_1async__enumerate__op__req.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1async__lock__op__req.html">boost::afio::async_lock_op_req</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1detail_1_1async__file__io__dispatcher__rwconverter.html">boost::afio::detail::async_file_io_dispatcher_rwconverter&lt; iswrite, T &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1utils_1_1secded__ecc.html">boost::afio::utils::secded_ecc&lt; blocksize &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the single error correcting double error detecting (SECDED) Hamming Error Correcting Code for a <em>blocksize</em> block of bytes. For example, a secdec_ecc&lt;8&gt; would be the very common 72,64 Hamming code used in ECC RAM, or secdec_ecc&lt;4096&gt; would be for a 32784,32768 Hamming code.  <a href="classboost_1_1afio_1_1utils_1_1secded__ecc.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1utils_1_1detail_1_1large__page__allocation.html">boost::afio::utils::detail::large_page_allocation</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1utils_1_1file__buffer__allocator.html">boost::afio::utils::file_buffer_allocator&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An STL allocator which allocates large TLB page memory.If the operating system is configured to allow it, this type of memory is particularly efficient for doing large scale file i/o. This is because the kernel must normally convert the scatter gather buffers you pass into extended scatter gather buffers as the memory you see as contiguous may not, and probably isn't, actually be contiguous in physical memory. Regions returned by this allocator <em>may</em> be allocated contiguously in physical memory and therefore the kernel can pass through your scatter gather buffers unmodified.  <a href="classboost_1_1afio_1_1utils_1_1file__buffer__allocator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1utils_1_1file__buffer__allocator_1_1rebind.html">boost::afio::utils::file_buffer_allocator&lt; T &gt;::rebind&lt; U &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1utils_1_1file__buffer__allocator_3_01void_01_4.html">boost::afio::utils::file_buffer_allocator&lt; void &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1utils_1_1file__buffer__allocator_3_01void_01_4_1_1rebind.html">boost::afio::utils::file_buffer_allocator&lt; void &gt;::rebind&lt; U &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstd_1_1hash_3_01boost_1_1afio_1_1path_01_4.html">std::hash&lt; boost::afio::path &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstd_1_1hash_3_01boost_1_1afio_1_1directory__entry_01_4.html">std::hash&lt; boost::afio::directory_entry &gt;</a></td></tr>
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1afio_1_1detail.html">boost::afio::detail</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>The namespace containing Boost.ASIO internal details. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1afio_1_1utils.html">boost::afio::utils</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Utility routines often useful when using AFIO. </p>
<br/></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="afio_8hpp.html#a7d6cb43e029a76765081fb3a2f47187d">BOOST_AFIO_HEADERS_ONLY</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if AFIO is compiled as headers only. Defaults to 1.  <a href="#a7d6cb43e029a76765081fb3a2f47187d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="afio_8hpp.html#a183b5c98a87ff28a56ea3bfdbe141ee9">BOOST_AFIO_USE_BOOST_THREAD</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if AFIO is bound against Boost.Thread or the C++ 11 STL thread. Defaults to 0.  <a href="#a183b5c98a87ff28a56ea3bfdbe141ee9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="afio_8hpp.html#ab5974d84a78dbcf8b072fca370f1291d">BOOST_AFIO_USE_BOOST_FILESYSTEM</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if AFIO is bound against Boost.Filesystem or the C++ 1z Filesystem TS. Defaults to 1 unless on VS2015 which provides a full Filesystem TS implementation.  <a href="#ab5974d84a78dbcf8b072fca370f1291d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="afio_8hpp.html#a5b90f4adb6bc09ca319c35c3448ee67a">ASIO_STANDALONE</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if AFIO is bound against standalone ASIO or Boost.ASIO. Defaults to undefined, and therefore Boost.ASIO.  <a href="#a5b90f4adb6bc09ca319c35c3448ee67a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a401610ff222fc25b2f5194a628d0ca52"></a><!-- doxytag: member="afio.hpp::BOOST_AFIO_V1_NAMESPACE" ref="a401610ff222fc25b2f5194a628d0ca52" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BOOST_AFIO_V1_NAMESPACE</b>&#160;&#160;&#160;boost::afio</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58c3ce35d210f818df9f4e3cf4c6575f"></a><!-- doxytag: member="afio.hpp::BOOST_AFIO_V1_NAMESPACE_BEGIN" ref="a58c3ce35d210f818df9f4e3cf4c6575f" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BOOST_AFIO_V1_NAMESPACE_BEGIN</b>&#160;&#160;&#160;namespace boost { namespace afio {</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2052639d8e84836a73d90c595e5dd1a6"></a><!-- doxytag: member="afio.hpp::BOOST_AFIO_V1_NAMESPACE_END" ref="a2052639d8e84836a73d90c595e5dd1a6" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BOOST_AFIO_V1_NAMESPACE_END</b>&#160;&#160;&#160;} }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a75b0e1ac1a86e60b2666ed2f64d36f"></a><!-- doxytag: member="afio.hpp::BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC" ref="a5a75b0e1ac1a86e60b2666ed2f64d36f" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab4f63024aa1238f1d6a067b3d7fb23c7"></a><!-- doxytag: member="afio.hpp::BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC" ref="ab4f63024aa1238f1d6a067b3d7fb23c7" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC</b>&#160;&#160;&#160;virtual</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__macros.html#ga8abeb465d2ca6fa15b3c3754697e5577">BOOST_AFIO_VALIDATE_INPUTS</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate inputs at the point of instantiation.  <a href="group__macros.html#ga8abeb465d2ca6fa15b3c3754697e5577"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>BOOST_AFIO_DECLARE_CLASS_ENUM_AS_BITFIELD</b>(type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>BOOST_AFIO_DIRECTORY_ENTRY_ACCESS_METHOD</b>(field)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a130389fe4d2bf643955597dfb34fe962"></a><!-- doxytag: member="afio.hpp::BOOST_AFIO_SECDEC_INTRINSICS" ref="a130389fe4d2bf643955597dfb34fe962" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BOOST_AFIO_SECDEC_INTRINSICS</b>&#160;&#160;&#160;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>BOOST_AFIO_ROUND</b>(n)</td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90c6d3eb9c6ffd8c9b90e0d4578415e0"></a><!-- doxytag: member="afio.hpp::off_t" ref="a90c6d3eb9c6ffd8c9b90e0d4578415e0" args="" -->
typedef unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><b>boost::afio::off_t</b></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>path_normalise</b> { <b>boost::afio::dos</b>, 
<b>boost::afio::guid_volume</b>, 
<b>boost::afio::guid_all</b>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The types of path normalisation available.  <a href="namespaceboost_1_1afio.html#afae7a43ba5460cf42cc5614c1948b136">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__file__flags.html#ga1615042683add1802cfc6dc86bd078ee">boost::afio::file_flags</a> { <br/>
&#160;&#160;<b>boost::afio::None</b> =  0, 
<b>boost::afio::Read</b> =  1, 
<b>boost::afio::Write</b> =  2, 
<b>boost::afio::ReadWrite</b> =  3, 
<br/>
&#160;&#160;<b>boost::afio::Append</b> =  4, 
<b>boost::afio::Truncate</b> =  8, 
<b>boost::afio::Create</b> =  16, 
<b>boost::afio::CreateOnlyIfNotExist</b> =  32, 
<br/>
&#160;&#160;<b>boost::afio::CreateCompressed</b> =  64, 
<b>boost::afio::WillBeSequentiallyAccessed</b> =  128, 
<b>boost::afio::WillBeRandomlyAccessed</b> =  256, 
<b>boost::afio::NoSparse</b> =  512, 
<br/>
&#160;&#160;<b>boost::afio::HoldParentOpen</b> =  (1 &lt;&lt; 10), 
<b>boost::afio::UniqueDirectoryHandle</b> =  (1 &lt;&lt; 11), 
<b>boost::afio::NoRaceProtection</b> =  (1 &lt;&lt; 12), 
<b>boost::afio::TemporaryFile</b> =  (1 &lt;&lt; 13), 
<br/>
&#160;&#160;<b>boost::afio::DeleteOnClose</b>, 
<b>boost::afio::OSDirect</b> =  (1 &lt;&lt; 16), 
<b>boost::afio::OSMMap</b> =  (1 &lt;&lt; 17), 
<b>OSLockable</b> =  (1 &lt;&lt; 18), 
<br/>
&#160;&#160;<b>boost::afio::AlwaysSync</b> =  (1 &lt;&lt; 24), 
<b>boost::afio::SyncOnClose</b> =  (1 &lt;&lt; 25), 
<b>boost::afio::int_hold_parent_open_nested</b> =  (1 &lt;&lt; 27), 
<b>boost::afio::int_file_share_delete</b> =  (1 &lt;&lt; 28), 
<br/>
&#160;&#160;<b>boost::afio::int_opening_link</b> =  (1 &lt;&lt; 29), 
<b>boost::afio::int_opening_dir</b> =  (1 &lt;&lt; 30)
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise file and directory open flags.  <a href="group__file__flags.html#ga1615042683add1802cfc6dc86bd078ee">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__op__flags.html#ga3d03d4b42e2ae303e282d0a1dec22976">boost::afio::async_op_flags</a> { <b>boost::afio::none</b> =  0, 
<b>boost::afio::immediate</b> =  1
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise async_op_flags flags.  <a href="group__async__op__flags.html#ga3d03d4b42e2ae303e282d0a1dec22976">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1afio_1_1detail.html#a0988089f34c099ad2ef946d6ff03c959">boost::afio::detail::OpType</a> { <br/>
&#160;&#160;<b>Unknown</b>, 
<b>UserCompletion</b>, 
<b>dir</b>, 
<b>rmdir</b>, 
<br/>
&#160;&#160;<b>file</b>, 
<b>rmfile</b>, 
<b>symlink</b>, 
<b>rmsymlink</b>, 
<br/>
&#160;&#160;<b>sync</b>, 
<b>close</b>, 
<b>read</b>, 
<b>write</b>, 
<br/>
&#160;&#160;<b>truncate</b>, 
<b>barrier</b>, 
<b>enumerate</b>, 
<b>adopt</b>, 
<br/>
&#160;&#160;<b>zero</b>, 
<b>extents</b>, 
<b>statfs</b>, 
<b>lock</b>, 
<br/>
&#160;&#160;<b>Last</b>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of operation.  <a href="namespaceboost_1_1afio_1_1detail.html#a0988089f34c099ad2ef946d6ff03c959">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1afio_1_1detail.html#af3116f1d2de8f7ba95f5a2e36c7bf251">boost::afio::detail::unit_testing_flags</a> { <a class="el" href="namespaceboost_1_1afio_1_1detail.html#af3116f1d2de8f7ba95f5a2e36c7bf251ac26df2d2a5f37aaaa525c1aa1057428a">boost::afio::detail::none</a> =  0, 
<a class="el" href="namespaceboost_1_1afio_1_1detail.html#af3116f1d2de8f7ba95f5a2e36c7bf251ace6ba4420a272bd919f0fb3cc5278e29">boost::afio::detail::no_symbol_lookup</a> =  (1 &lt;&lt; 0)
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__metadata__flags.html#ga228a95ca96f053e74e69e6d1ab23eccb">boost::afio::metadata_flags</a> { <br/>
&#160;&#160;<b>boost::afio::None</b> =  0, 
<b>dev</b> =  1 &lt;&lt; 0, 
<b>ino</b> =  1 &lt;&lt; 1, 
<b>type</b> =  1 &lt;&lt; 2, 
<br/>
&#160;&#160;<b>perms</b> =  1 &lt;&lt; 3, 
<b>nlink</b> =  1 &lt;&lt; 4, 
<b>uid</b> =  1 &lt;&lt; 5, 
<b>gid</b> =  1 &lt;&lt; 6, 
<br/>
&#160;&#160;<b>rdev</b> =  1 &lt;&lt; 7, 
<b>atim</b> =  1 &lt;&lt; 8, 
<b>mtim</b> =  1 &lt;&lt; 9, 
<b>ctim</b> =  1 &lt;&lt; 10, 
<br/>
&#160;&#160;<b>size</b> =  1 &lt;&lt; 11, 
<b>allocated</b> =  1 &lt;&lt; 12, 
<b>blocks</b> =  1 &lt;&lt; 13, 
<b>blksize</b> =  1 &lt;&lt; 14, 
<br/>
&#160;&#160;<b>flags</b> =  1 &lt;&lt; 15, 
<b>gen</b> =  1 &lt;&lt; 16, 
<b>birthtim</b> =  1 &lt;&lt; 17, 
<b>sparse</b> =  1 &lt;&lt; 24, 
<br/>
&#160;&#160;<b>compressed</b> =  1 &lt;&lt; 25, 
<b>boost::afio::All</b> =  (size_t) -1
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitflags for availability of metadata from `struct stat_t`.  <a href="group__metadata__flags.html#ga228a95ca96f053e74e69e6d1ab23eccb">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fs__metadata__flags.html#gadc548bc518f40378c9c9c97f4a994438">boost::afio::fs_metadata_flags</a> { <br/>
&#160;&#160;<b>boost::afio::None</b> =  0, 
<b>flags</b> =  1 &lt;&lt; 15, 
<b>bsize</b> =  1 &lt;&lt; 2, 
<b>iosize</b> =  1 &lt;&lt; 3, 
<br/>
&#160;&#160;<b>blocks</b> =  1 &lt;&lt; 13, 
<b>bfree</b> =  1 &lt;&lt; 5, 
<b>bavail</b> =  1 &lt;&lt; 6, 
<b>files</b> =  1 &lt;&lt; 7, 
<br/>
&#160;&#160;<b>ffree</b> =  1 &lt;&lt; 8, 
<b>namemax</b> =  1 &lt;&lt; 9, 
<b>owner</b> =  1 &lt;&lt; 10, 
<b>fsid</b> =  1 &lt;&lt; 11, 
<br/>
&#160;&#160;<b>fstypename</b> =  1 &lt;&lt; 12, 
<b>mntfromname</b> =  1 &lt;&lt; 13, 
<b>mntonname</b> =  1 &lt;&lt; 14, 
<b>boost::afio::All</b> =  (size_t) -1
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitflags for availability of metadata from `struct statfs_t`.  <a href="group__fs__metadata__flags.html#gadc548bc518f40378c9c9c97f4a994438">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOST_AFIO_DECL <br class="typebreak"/>
std::shared_ptr<br class="typebreak"/>
&lt; std_thread_pool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__process__threadpool.html#gabb4747cc11ef3ee1bbb969bc78c238bb">boost::afio::process_threadpool</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the process threadpool.  <a href="group__process__threadpool.html#gabb4747cc11ef3ee1bbb969bc78c238bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0e3d02935dd8a2a8277daead11eb4b0"></a><!-- doxytag: member="afio.hpp::operator&lt;" ref="ae0e3d02935dd8a2a8277daead11eb4b0" args="(const path &amp;lhs, const path &amp;rhs)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>boost::afio::operator&lt;</b> (const path &amp;lhs, const path &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae19787194c1042aef3dcb693f4329559"></a><!-- doxytag: member="afio.hpp::operator&lt;=" ref="ae19787194c1042aef3dcb693f4329559" args="(const path &amp;lhs, const path &amp;rhs)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>boost::afio::operator&lt;=</b> (const path &amp;lhs, const path &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c800de48262cde6cffb71bcaff872db"></a><!-- doxytag: member="afio.hpp::operator&gt;" ref="a4c800de48262cde6cffb71bcaff872db" args="(const path &amp;lhs, const path &amp;rhs)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>boost::afio::operator&gt;</b> (const path &amp;lhs, const path &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8779e551d691aeeba100fc91554961f6"></a><!-- doxytag: member="afio.hpp::operator&gt;=" ref="a8779e551d691aeeba100fc91554961f6" args="(const path &amp;lhs, const path &amp;rhs)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>boost::afio::operator&gt;=</b> (const path &amp;lhs, const path &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98dded77e29c80a11adf0b788d64848c"></a><!-- doxytag: member="afio.hpp::operator==" ref="a98dded77e29c80a11adf0b788d64848c" args="(const path &amp;lhs, const path &amp;rhs)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>boost::afio::operator==</b> (const path &amp;lhs, const path &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac988be6a1643f87dcf367ecb5b74d256"></a><!-- doxytag: member="afio.hpp::operator!=" ref="ac988be6a1643f87dcf367ecb5b74d256" args="(const path &amp;lhs, const path &amp;rhs)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>boost::afio::operator!=</b> (const path &amp;lhs, const path &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24d1607ab696725ffba9dfbf81269a7f"></a><!-- doxytag: member="afio.hpp::operator/" ref="a24d1607ab696725ffba9dfbf81269a7f" args="(const path &amp;lhs, const path &amp;rhs)" -->
path&#160;</td><td class="memItemRight" valign="bottom"><b>boost::afio::operator/</b> (const path &amp;lhs, const path &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a654ce987a7ca43daebb51c2dfcd173f4"></a><!-- doxytag: member="afio.hpp::operator&lt;&lt;" ref="a654ce987a7ca43daebb51c2dfcd173f4" args="(std::ostream &amp;s, const path &amp;p)" -->
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>boost::afio::operator&lt;&lt;</b> (std::ostream &amp;s, const path &amp;p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">filesystem::path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__normalise__path.html#ga39a6017e4b2141d24e37f89f3ef03416">boost::afio::normalise_path</a> (path p, path_normalise type=path_normalise::dos)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a normalised filesystem::path from an AFIO path.  <a href="group__normalise__path.html#ga39a6017e4b2141d24e37f89f3ef03416"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa676bdf762c5e8d6f8826e199cae924f"></a><!-- doxytag: member="afio.hpp::static_assert" ref="aa676bdf762c5e8d6f8826e199cae924f" args="(static_cast&lt; size_t &gt;(OpType::Last)==sizeof(optypes)/sizeof(*optypes),&quot;You forgot to fix up the strings matching OpType&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>boost::afio::detail::static_assert</b> (static_cast&lt; size_t &gt;(OpType::Last)==sizeof(optypes)/sizeof(*optypes),&quot;You forgot to fix up the strings matching OpType&quot;)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a3b7e2a409d76c0d5d83f4dbe54a6d4f0"></a><!-- doxytag: member="afio.hpp::decode_relative_path" ref="a3b7e2a409d76c0d5d83f4dbe54a6d4f0" args="(async_path_op_req &amp;req, bool force_absolute=false)" -->
template&lt;class Impl , class Handle &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; async_io_handle &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>boost::afio::detail::decode_relative_path</b> (async_path_op_req &amp;req, bool force_absolute=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOST_AFIO_DECL <br class="typebreak"/>
std::shared_ptr<br class="typebreak"/>
&lt; async_file_io_dispatcher_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher.html#ga412e5ba3eaf5c1df0499dad2ddd79fb8">boost::afio::make_async_file_io_dispatcher</a> (std::shared_ptr&lt; thread_source &gt; threadpool=process_threadpool(), file_flags flagsforce=file_flags::None, file_flags flagsmask=file_flags::None)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Instatiates the best available async_file_io_dispatcher implementation for this system.  <a href="group__async__file__io__dispatcher.html#ga412e5ba3eaf5c1df0499dad2ddd79fb8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ab2379f238e2ebbacf46d54cbd434da38"></a><!-- doxytag: member="afio.hpp::when_all_ops_do" ref="ab2379f238e2ebbacf46d54cbd434da38" args="(std::shared_ptr&lt; when_all_state &gt; state)" -->
template&lt;bool rethrow&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>boost::afio::detail::when_all_ops_do</b> (std::shared_ptr&lt; when_all_state &gt; state)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a1cf9aac5f43844e9b29f188d61a74656"></a><!-- doxytag: member="afio.hpp::when_all_ops" ref="a1cf9aac5f43844e9b29f188d61a74656" args="(Iterator first, Iterator last)" -->
template&lt;bool rethrow, class Iterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">future&lt; std::vector<br class="typebreak"/>
&lt; std::shared_ptr<br class="typebreak"/>
&lt; async_io_handle &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>boost::afio::detail::when_all_ops</b> (Iterator first, Iterator last)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a65c7191bc488fd3f4e4f1ed701588bca"></a><!-- doxytag: member="afio.hpp::when_any_ops_do" ref="a65c7191bc488fd3f4e4f1ed701588bca" args="(std::shared_ptr&lt; when_any_state &gt; state, size_t idx, size_t id, async_io_op h)" -->
template&lt;bool rethrow&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, <br class="typebreak"/>
std::shared_ptr<br class="typebreak"/>
&lt; async_io_handle &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>boost::afio::detail::when_any_ops_do</b> (std::shared_ptr&lt; when_any_state &gt; state, size_t idx, size_t id, async_io_op h)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a0a09827ed7a36972585fda14fec43a13"></a><!-- doxytag: member="afio.hpp::when_any_ops" ref="a0a09827ed7a36972585fda14fec43a13" args="(Iterator first, Iterator last)" -->
template&lt;bool rethrow, class Iterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">future&lt; std::shared_ptr<br class="typebreak"/>
&lt; async_io_handle &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>boost::afio::detail::when_any_ops</b> (Iterator first, Iterator last)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Iterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">detail::enable_if_async_op<br class="typebreak"/>
&lt; true, typename <br class="typebreak"/>
Iterator::value_type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__when__all__ops.html#gadd8ae93c91c23b1011dfdf002db07e9e">boost::afio::when_all</a> (std::nothrow_t _, Iterator first, Iterator last)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a result when all the supplied ops complete. Does not propagate exception states.  <a href="group__when__all__ops.html#gadd8ae93c91c23b1011dfdf002db07e9e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Iterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">detail::enable_if_async_op<br class="typebreak"/>
&lt; false, typename <br class="typebreak"/>
Iterator::value_type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__when__all__ops.html#ga85c6d5c463b1ecffdc2a6bda4f040bb0">boost::afio::when_any</a> (std::nothrow_t _, Iterator first, Iterator last)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a result when any the supplied ops complete. Does not propagate exception states.  <a href="group__when__all__ops.html#ga85c6d5c463b1ecffdc2a6bda4f040bb0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">future&lt; std::vector<br class="typebreak"/>
&lt; std::shared_ptr<br class="typebreak"/>
&lt; async_io_handle &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__when__all__ops.html#ga5598f81e0788f6acd2258263009de875">boost::afio::when_all</a> (std::nothrow_t _, std::vector&lt; async_io_op &gt; ops)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a result when all the supplied ops complete. Does not propagate exception states.  <a href="group__when__all__ops.html#ga5598f81e0788f6acd2258263009de875"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">future&lt; std::shared_ptr<br class="typebreak"/>
&lt; async_io_handle &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__when__all__ops.html#gaeb4173eee90e57cc0646056bd14603de">boost::afio::when_any</a> (std::nothrow_t _, std::vector&lt; async_io_op &gt; ops)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a result when any the supplied ops complete. Does not propagate exception states.  <a href="group__when__all__ops.html#gaeb4173eee90e57cc0646056bd14603de"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Iterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">detail::enable_if_async_op<br class="typebreak"/>
&lt; true, typename <br class="typebreak"/>
Iterator::value_type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__when__all__ops.html#gaaf00f394b0af6575df503d4527788c5d">boost::afio::when_all</a> (Iterator first, Iterator last)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a result when all the supplied ops complete. Propagates exception states.  <a href="group__when__all__ops.html#gaaf00f394b0af6575df503d4527788c5d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Iterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">detail::enable_if_async_op<br class="typebreak"/>
&lt; false, typename <br class="typebreak"/>
Iterator::value_type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__when__all__ops.html#ga1a452f7d0c7a0517e824cddb0816e872">boost::afio::when_any</a> (Iterator first, Iterator last)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a result when any the supplied ops complete. Propagates exception states.  <a href="group__when__all__ops.html#ga1a452f7d0c7a0517e824cddb0816e872"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">future&lt; std::vector<br class="typebreak"/>
&lt; std::shared_ptr<br class="typebreak"/>
&lt; async_io_handle &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__when__all__ops.html#ga6591b9bbaf576183995ba8612f1c86d5">boost::afio::when_all</a> (std::vector&lt; async_io_op &gt; ops)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a result when all the supplied ops complete. Propagates exception states.  <a href="group__when__all__ops.html#ga6591b9bbaf576183995ba8612f1c86d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">future&lt; std::shared_ptr<br class="typebreak"/>
&lt; async_io_handle &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__when__all__ops.html#ga4a98962e8807e8f5fa31bb14fa430374">boost::afio::when_any</a> (std::vector&lt; async_io_op &gt; ops)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a result when any the supplied ops complete. Propagates exception states.  <a href="group__when__all__ops.html#ga4a98962e8807e8f5fa31bb14fa430374"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">future&lt; std::vector<br class="typebreak"/>
&lt; std::shared_ptr<br class="typebreak"/>
&lt; async_io_handle &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__when__all__ops.html#ga175bb31dd07b8c716c85f5bfdc17c9df">boost::afio::when_all</a> (std::nothrow_t _, async_io_op op)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a result when the supplied op completes. Does not propagate exception states.  <a href="group__when__all__ops.html#ga175bb31dd07b8c716c85f5bfdc17c9df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">future&lt; std::vector<br class="typebreak"/>
&lt; std::shared_ptr<br class="typebreak"/>
&lt; async_io_handle &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__when__all__ops.html#ga3a4b5bc5ed128e7ef337fe164f897782">boost::afio::when_all</a> (async_io_op op)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a result when the supplied op completes. Propagates exception states.  <a href="group__when__all__ops.html#ga3a4b5bc5ed128e7ef337fe164f897782"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; asio::mutable_buffer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__to__asio__buffers.html#ga772fe53eebaa2177dc53227bbef03f3f">boost::afio::to_asio_buffers</a> (T &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Any trivial type T or STL container.  <a href="group__to__asio__buffers.html#ga772fe53eebaa2177dc53227bbef03f3f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; asio::const_buffer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__to__asio__buffers.html#ga0967653554334e6532eeaf4de0f7fe07">boost::afio::to_asio_buffers</a> (const T &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Any trivial type T or STL container.  <a href="group__to__asio__buffers.html#ga0967653554334e6532eeaf4de0f7fe07"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; asio::mutable_buffer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__to__asio__buffers.html#ga403430fff790e5142116cfbf562cdf07">boost::afio::to_asio_buffers</a> (T(&amp;v)[N])</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A buffer at v sized N*sizeof(T)  <a href="group__to__asio__buffers.html#ga403430fff790e5142116cfbf562cdf07"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; asio::const_buffer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__to__asio__buffers.html#gac055cc87431a0c5700e9cda29453f3bb">boost::afio::to_asio_buffers</a> (const T(&amp;v)[N])</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A buffer at v sized N*sizeof(T)  <a href="group__to__asio__buffers.html#gac055cc87431a0c5700e9cda29453f3bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; asio::mutable_buffer &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__to__asio__buffers.html#ga4d5b48b8b62041f0eb1d332b6ee3c8a9">boost::afio::to_asio_buffers</a> (asio::mutable_buffer &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Passing through asio::mutable_buffer.  <a href="group__to__asio__buffers.html#ga4d5b48b8b62041f0eb1d332b6ee3c8a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; asio::const_buffer &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__to__asio__buffers.html#gaad8ba2d78365cbb49705467d8e3923b8">boost::afio::to_asio_buffers</a> (asio::const_buffer &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Passing through asio::const_buffer.  <a href="group__to__asio__buffers.html#gaad8ba2d78365cbb49705467d8e3923b8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; asio::mutable_buffer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__to__asio__buffers.html#gae9038306b955f1af06f765ae0f2880a1">boost::afio::to_asio_buffers</a> (T *v, size_t length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A buffer at v sized length*sizeof(T)  <a href="group__to__asio__buffers.html#gae9038306b955f1af06f765ae0f2880a1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; asio::const_buffer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__to__asio__buffers.html#gad414435390ce9e4cfe4bf85d43447c0b">boost::afio::to_asio_buffers</a> (const T *v, size_t length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A buffer at v sized length*sizeof(T)  <a href="group__to__asio__buffers.html#gad414435390ce9e4cfe4bf85d43447c0b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; asio::mutable_buffer &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__to__asio__buffers.html#ga6d517384616b5648508780391b3e8f5f">boost::afio::to_asio_buffers</a> (void *v, size_t length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A buffer at v sized length.  <a href="group__to__asio__buffers.html#ga6d517384616b5648508780391b3e8f5f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; asio::const_buffer &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__to__asio__buffers.html#ga42be30127e97be9c73906906e74b24b0">boost::afio::to_asio_buffers</a> (const void *v, size_t length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A buffer at v sized length.  <a href="group__to__asio__buffers.html#ga42be30127e97be9c73906906e74b24b0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__make__async__data__op__req.html#gaff49f3ca9c8a8796ab7972a40f324122">boost::afio::make_async_data_op_req</a> (async_io_op _precondition, T &amp;&amp;v, off_t _where)-&gt; decltype(detail</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience instantiator of a <a class="el" href="structboost_1_1afio_1_1async__data__op__req.html" title="A convenience bundle of precondition, data and where for reading into a T as specified by its to_asio...">async_data_op_req</a>, letting the compiler deduce the template specialisation to use.  <a href="group__make__async__data__op__req.html#gaff49f3ca9c8a8796ab7972a40f324122"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">async_data_op_req&lt; const <br class="typebreak"/>
std::initializer_list&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__make__async__data__op__req.html#ga40032d509f14a1c60cbf9989bc06d038">boost::afio::make_async_data_op_req</a> (async_io_op _precondition, const std::initializer_list&lt; T &gt; &amp;v, off_t _where)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience instantiator of a <a class="el" href="structboost_1_1afio_1_1async__data__op__req.html" title="A convenience bundle of precondition, data and where for reading into a T as specified by its to_asio...">async_data_op_req</a>, letting the compiler deduce the template specialisation to use.  <a href="group__make__async__data__op__req.html#ga40032d509f14a1c60cbf9989bc06d038"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__make__async__data__op__req.html#ga878313b5b405a1c2c73aabc1078bf57c">boost::afio::make_async_data_op_req</a> (async_io_op _precondition, T &amp;&amp;v, size_t _length, off_t _where)-&gt; decltype(detail</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience instantiator of a <a class="el" href="structboost_1_1afio_1_1async__data__op__req.html" title="A convenience bundle of precondition, data and where for reading into a T as specified by its to_asio...">async_data_op_req</a>, letting the compiler deduce the template specialisation to use.  <a href="group__make__async__data__op__req.html#ga878313b5b405a1c2c73aabc1078bf57c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a24ece0c0005765247dfbb0cb49e757b3"></a><!-- doxytag: member="afio.hpp::doCall" ref="a24ece0c0005765247dfbb0cb49e757b3" args="(size_t, async_io_op _, std::shared_ptr&lt; tasktype &gt; c)" -->
template&lt;class tasktype &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, <br class="typebreak"/>
std::shared_ptr<br class="typebreak"/>
&lt; async_io_handle &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>boost::afio::detail::doCall</b> (size_t, async_io_op _, std::shared_ptr&lt; tasktype &gt; c)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOST_AFIO_DECL std::vector<br class="typebreak"/>
&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga9b33da2bc3cd4989446286eebb19ea70">boost::afio::utils::page_sizes</a> (bool only_actually_available=true) noexcept</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the page sizes of this architecture which is useful for calculating direct i/o multiples.  <a href="group__utils.html#ga9b33da2bc3cd4989446286eebb19ea70"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga55768bbb4e68c40408d1e8e7b7ffd6bd">boost::afio::utils::file_buffer_default_size</a> () noexcept</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reasonable default size for <a class="el" href="classboost_1_1afio_1_1utils_1_1file__buffer__allocator.html" title="An STL allocator which allocates large TLB page memory.If the operating system is configured to allow...">file_buffer_allocator</a>, typically the closest page size from <a class="el" href="group__utils.html#ga9b33da2bc3cd4989446286eebb19ea70" title="Returns the page sizes of this architecture which is useful for calculating direct i/o multiples...">page_sizes()</a> to 1Mb.  <a href="group__utils.html#ga55768bbb4e68c40408d1e8e7b7ffd6bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOST_AFIO_DECL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga1fbfc2cc5dc368f487b8d78e6ba07979">boost::afio::utils::random_fill</a> (char *buffer, size_t bytes)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the buffer supplied with cryptographically strong randomness. Uses the OS kernel API.  <a href="group__utils.html#ga1fbfc2cc5dc368f487b8d78e6ba07979"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga2833abcfab4aed29c3e44abc037a1010">boost::afio::utils::to_hex_string</a> (char *out, size_t outlen, const char *_in, size_t inlen)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a number to a hex string. Out buffer can be same as in buffer.  <a href="group__utils.html#ga2833abcfab4aed29c3e44abc037a1010"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1afio_1_1utils.html#a8579699e78a933faad9a3615eea537ff">boost::afio::utils::to_hex_string</a> (std::string in)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga4dcd0afda0bee44936aefef80a6f012f">boost::afio::utils::from_hex_string</a> (char *out, size_t outlen, const char *in, size_t inlen)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a hex string to a number. Out buffer can be same as in buffer.  <a href="group__utils.html#ga4dcd0afda0bee44936aefef80a6f012f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#gab190a12ca7648c31c9bd65defb23a99b">boost::afio::utils::random_string</a> (size_t randomlen)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a cryptographically random string capable of being used as a filename. Essentially <a class="el" href="group__utils.html#ga1fbfc2cc5dc368f487b8d78e6ba07979" title="Fills the buffer supplied with cryptographically strong randomness. Uses the OS kernel API...">random_fill()</a> + <a class="el" href="group__utils.html#ga2833abcfab4aed29c3e44abc037a1010" title="Converts a number to a hex string. Out buffer can be same as in buffer.">to_hex_string()</a>.  <a href="group__utils.html#gab190a12ca7648c31c9bd65defb23a99b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a906037d22fbfb40d1eaf3e9bbda63fe6"></a><!-- doxytag: member="afio.hpp::calculate_large_page_allocation" ref="a906037d22fbfb40d1eaf3e9bbda63fe6" args="(size_t bytes)" -->
large_page_allocation&#160;</td><td class="memItemRight" valign="bottom"><b>boost::afio::utils::detail::calculate_large_page_allocation</b> (size_t bytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d8e6b475fa688c976ab184f52f6d41c"></a><!-- doxytag: member="afio.hpp::allocate_large_pages" ref="a2d8e6b475fa688c976ab184f52f6d41c" args="(size_t bytes)" -->
BOOST_AFIO_DECL <br class="typebreak"/>
large_page_allocation&#160;</td><td class="memItemRight" valign="bottom"><b>boost::afio::utils::detail::allocate_large_pages</b> (size_t bytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96d16893a45034c25d503c96c4e9890b"></a><!-- doxytag: member="afio.hpp::deallocate_large_pages" ref="a96d16893a45034c25d503c96c4e9890b" args="(void *p, size_t bytes)" -->
BOOST_AFIO_DECL void&#160;</td><td class="memItemRight" valign="bottom"><b>boost::afio::utils::detail::deallocate_large_pages</b> (void *p, size_t bytes)</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad9426571fbc2fb9d9d54fd3f252ff21"></a><!-- doxytag: member="afio.hpp::optypes" ref="aad9426571fbc2fb9d9d54fd3f252ff21" args="[]" -->
static const char *&#160;</td><td class="memItemRight" valign="bottom"><b>boost::afio::detail::optypes</b> [] = {&quot;unknown&quot;, &quot;UserCompletion&quot;, &quot;dir&quot;, &quot;rmdir&quot;, &quot;file&quot;, &quot;rmfile&quot;, &quot;symlink&quot;, &quot;rmsymlink&quot;, &quot;sync&quot;, &quot;close&quot;, &quot;read&quot;, &quot;write&quot;, &quot;truncate&quot;, &quot;barrier&quot;, &quot;enumerate&quot;, &quot;adopt&quot;, &quot;zero&quot;, &quot;extents&quot;, &quot;statfs&quot;, &quot;lock&quot;}</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Provides a batch asynchronous file i/o implementation based on Boost.ASIO. </p>

<p>Definition in file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>
</div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="a7d6cb43e029a76765081fb3a2f47187d"></a><!-- doxytag: member="afio.hpp::BOOST_AFIO_HEADERS_ONLY" ref="a7d6cb43e029a76765081fb3a2f47187d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="afio_8hpp.html#a7d6cb43e029a76765081fb3a2f47187d">BOOST_AFIO_HEADERS_ONLY</a>&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines if AFIO is compiled as headers only. Defaults to 1. </p>

</div>
</div>
<a class="anchor" id="a183b5c98a87ff28a56ea3bfdbe141ee9"></a><!-- doxytag: member="afio.hpp::BOOST_AFIO_USE_BOOST_THREAD" ref="a183b5c98a87ff28a56ea3bfdbe141ee9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="afio_8hpp.html#a183b5c98a87ff28a56ea3bfdbe141ee9">BOOST_AFIO_USE_BOOST_THREAD</a>&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines if AFIO is bound against Boost.Thread or the C++ 11 STL thread. Defaults to 0. </p>

</div>
</div>
<a class="anchor" id="ab5974d84a78dbcf8b072fca370f1291d"></a><!-- doxytag: member="afio.hpp::BOOST_AFIO_USE_BOOST_FILESYSTEM" ref="ab5974d84a78dbcf8b072fca370f1291d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="afio_8hpp.html#ab5974d84a78dbcf8b072fca370f1291d">BOOST_AFIO_USE_BOOST_FILESYSTEM</a>&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines if AFIO is bound against Boost.Filesystem or the C++ 1z Filesystem TS. Defaults to 1 unless on VS2015 which provides a full Filesystem TS implementation. </p>

</div>
</div>
<a class="anchor" id="a5b90f4adb6bc09ca319c35c3448ee67a"></a><!-- doxytag: member="afio.hpp::ASIO_STANDALONE" ref="a5b90f4adb6bc09ca319c35c3448ee67a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="afio_8hpp.html#a5b90f4adb6bc09ca319c35c3448ee67a">ASIO_STANDALONE</a>&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines if AFIO is bound against standalone ASIO or Boost.ASIO. Defaults to undefined, and therefore Boost.ASIO. </p>

</div>
</div>
<a class="anchor" id="a933046d7a31248aa271a978579ee8977"></a><!-- doxytag: member="afio.hpp::BOOST_AFIO_DECLARE_CLASS_ENUM_AS_BITFIELD" ref="a933046d7a31248aa271a978579ee8977" args="(type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BOOST_AFIO_DECLARE_CLASS_ENUM_AS_BITFIELD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keyword">inline</span> BOOST_CONSTEXPR type operator&amp;(type a, type b) { <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>type<span class="keyword">&gt;</span>(<span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(a) &amp; static_cast&lt;size_t&gt;(b)); }                                                                                                                                                                                         \
  inline BOOST_CONSTEXPR type operator|(type a, type b) { <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>type<span class="keyword">&gt;</span>(<span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(a) | static_cast&lt;size_t&gt;(b)); }                                                                                                                                                                                         \
  inline BOOST_CONSTEXPR type operator~(type a) { <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>type<span class="keyword">&gt;</span>(~static_cast&lt;<span class="keywordtype">size_t</span>&gt;(a)); }                                                                                                                                                                                                                         \
  inline BOOST_CONSTEXPR <span class="keywordtype">bool</span> operator!(type a) { <span class="keywordflow">return</span> 0 == <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(a); }
</pre></div>
<p>Definition at line <a class="el" href="afio_8hpp_source.html#l00840">840</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac794ed8c3e9fc1a99bd54d5b993d2b6c"></a><!-- doxytag: member="afio.hpp::BOOST_AFIO_DIRECTORY_ENTRY_ACCESS_METHOD" ref="ac794ed8c3e9fc1a99bd54d5b993d2b6c" args="(field)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BOOST_AFIO_DIRECTORY_ENTRY_ACCESS_METHOD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">field</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">fieldtype st_##field(std::shared_ptr&lt;async_io_handle&gt; dirh = std::shared_ptr&lt;async_io_handle&gt;())                                                                                                                                                                                                                             \
  {                                                                                                                                                                                                                                                                                                                            \
    if(!(have_metadata &amp; metadata_flags::field))                                                                                                                                                                                                                                                                               \
    {                                                                                                                                                                                                                                                                                                                          \
      _int_fetch(metadata_flags::field, dirh);                                                                                                                                                                                                                                                                                 \
    }                                                                                                                                                                                                                                                                                                                          \
    return stat.st_##field;                                                                                                                                                                                                                                                                                                    \
  }
</pre></div>
<p>Definition at line <a class="el" href="afio_8hpp_source.html#l01236">1236</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4eff8ea7c1ee25af59b33fa679c9793e"></a><!-- doxytag: member="afio.hpp::BOOST_AFIO_ROUND" ref="a4eff8ea7c1ee25af59b33fa679c9793e" args="(n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BOOST_AFIO_ROUND</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">prefetch[0] = ecc_table[(i + 0) * 8 + n];                                                                                                                                                                                                                                                                                    \
  prefetch[1] = ecc_table[(i + 1) * 8 + n];                                                                                                                                                                                                                                                                                    \
  prefetch[2] = ecc_table[(i + 2) * 8 + n];                                                                                                                                                                                                                                                                                    \
  prefetch[3] = ecc_table[(i + 3) * 8 + n];                                                                                                                                                                                                                                                                                    \
  prefetch[4] = ecc_table[(i + 4) * 8 + n];                                                                                                                                                                                                                                                                                    \
  prefetch[5] = ecc_table[(i + 5) * 8 + n];                                                                                                                                                                                                                                                                                    \
  prefetch[6] = ecc_table[(i + 6) * 8 + n];                                                                                                                                                                                                                                                                                    \
  prefetch[7] = ecc_table[(i + 7) * 8 + n];                                                                                                                                                                                                                                                                                    \
  if(c[0] &amp; ((unit_type) 1 &lt;&lt; n))                                                                                                                                                                                                                                                                                              \
    ecc ^= prefetch[0];                                                                                                                                                                                                                                                                                                        \
  if(c[1] &amp; ((unit_type) 1 &lt;&lt; n))                                                                                                                                                                                                                                                                                              \
    ecc ^= prefetch[1];                                                                                                                                                                                                                                                                                                        \
  if(c[2] &amp; ((unit_type) 1 &lt;&lt; n))                                                                                                                                                                                                                                                                                              \
    ecc ^= prefetch[2];                                                                                                                                                                                                                                                                                                        \
  if(c[3] &amp; ((unit_type) 1 &lt;&lt; n))                                                                                                                                                                                                                                                                                              \
    ecc ^= prefetch[3];                                                                                                                                                                                                                                                                                                        \
  if(c[4] &amp; ((unit_type) 1 &lt;&lt; n))                                                                                                                                                                                                                                                                                              \
    ecc ^= prefetch[4];                                                                                                                                                                                                                                                                                                        \
  if(c[5] &amp; ((unit_type) 1 &lt;&lt; n))                                                                                                                                                                                                                                                                                              \
    ecc ^= prefetch[5];                                                                                                                                                                                                                                                                                                        \
  if(c[6] &amp; ((unit_type) 1 &lt;&lt; n))                                                                                                                                                                                                                                                                                              \
    ecc ^= prefetch[6];                                                                                                                                                                                                                                                                                                        \
  if(c[7] &amp; ((unit_type) 1 &lt;&lt; n))                                                                                                                                                                                                                                                                                              \
    ecc ^= prefetch[7];
</pre></div>
</div>
</div>
</div><!-- contents -->
<hr size="1">
<table width="100%">
<tbody>
<tr>
<td align="left"><small>
<p>January, 2014</p>
</small></td>
<td align="right">
<small>
Copyright &copy; 2013-2014 Niall Douglas, Cork, Ireland<br>
Copyright &copy; 2013 Paul Kirth, California<br>
</small>
</td>
</tr>
</tbody>
</table>

<address style="text-align: right;"><small>
Documentation is generated by&nbsp;<a href="http://www.doxygen.org/index.html">Doxygen</a>
</small></address>
</body>
</html>
