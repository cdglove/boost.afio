<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Quick Start</title>
<link rel="stylesheet" href="../../../libs/afio/doc/html/myboostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.76.1">
<link rel="home" href="../afio.html" title="Chapter&#160;1.&#160;Boost.AFIO 1.30">
<link rel="up" href="../afio.html" title="Chapter&#160;1.&#160;Boost.AFIO 1.30">
<link rel="prev" href="compilation.html" title="Compilation">
<link rel="next" href="quickstart/hello_world.html" title="Hello World, asynchronously!">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../boost.png"></td>
<td align="center"><a href="../../../index.html">Home</a></td>
<td align="center"><a href="../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="compilation.html"><img src="../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../afio.html"><img src="../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../afio.html"><img src="../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="quickstart/hello_world.html"><img src="../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="afio.quickstart"></a><a class="link" href="quickstart.html" title="Quick Start">Quick Start</a>
</h2></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="quickstart/hello_world.html">Hello World, asynchronously!</a></span></dt>
<dt><span class="section"><a href="quickstart/file_concat.html">A less toy example: Concatenating
      files</a></span></dt>
<dt><span class="section"><a href="quickstart/atomic_logging.html">Achieving atomicity on
      the filing system</a></span></dt>
<dt><span class="section"><a href="quickstart/filesystem_races.html">Handling races on the
      filing system</a></span></dt>
<dt><span class="section"><a href="quickstart/so_what.html">What benefit does asynchronous
      file i/o bring me? A demonstration of AFIO's power</a></span></dt>
</dl></div>
<p>
      So why bother with Boost.AFIO? What's wrong with the STL iostreams and Filesystem?
    </p>
<p>
      The answer is that there is nothing wrong with either for 95% of use cases.
      Performance of both is pretty good in fact most of the time &#8212; which
      actually isn't that surprising as C++ is a pay-for-what-you-use systems language.
      If however you have ever experienced any of these problems, then AFIO may be
      useful to you:
    </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
          Your spinning magnetic rust hard drive goes bananas when some routine in
          your code tries to do something to storage, and latency per op starts heading
          into the seconds range.
        </li>
<li class="listitem">
          Your super fast SSD which is supposed to be delivering hundreds of thousands
          of ops/sec is barely managing a tenth of its supposed ability with your
          code. After reading about the importance of high queue depth to maximising
          performance from SSDs, you try opening many handles to the same file and
          firing an army of thread pool workers at the problem to try and increase
          queue depth, but your performance actually drops over the single threaded
          case.
        </li>
<li class="listitem">
          Your code has to interact with a regularly changing filesystem and not
          get weird race errors e.g. you try to create a new file in path /X/Y/Z,
          but some other program has just renamed directory /X/Y to /A/B in the time
          between you deciding on /X/Y/Z and getting round to it.
        </li>
<li class="listitem">
          Your code keeps file handles open a long time in a place where others might
          delete or rename them, including any part of the directory hierarchy preceding
          the file.
        </li>
<li class="listitem">
          Deleting directory trees randomly fails on Microsoft Windows for no obvious
          reason.
        </li>
<li class="listitem">
          Your code needs to read and write files concurrently to other code without
          resorting to shared memory region tricks e.g. if the files reside on a
          Samba or NFS network shared drive.
        </li>
<li class="listitem">
          Your CPU needs to be doing more useful work instead of copying memory to
          and from disc i/o buffers. As great as the STL iostream buffering is, unless
          disabled it doubles the LL cache pressure on your CPU, evicting other more
          useful data. The STL iostreams design almost certainly won't allow the
          kernel use VM tricks to directly busmaster DMA from its buffers to the
          hard drive, so the kernel will have to copy those buffers a third time.
          That means that for every 1Kb you read or write you are evicted, as a minimum,
          3Kb from the LL caches in your CPU, all of which must be refilled with
          more useful data later.
        </li>
<li class="listitem">
          Your code wants to experience various filing system features identically
          across platforms which also work on shared Samba and NFS network drives,
          such as:
          <div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
                Deleting and renaming open files.
              </li>
<li class="listitem">
                Files having unique inode values.
              </li>
<li class="listitem">
                POSIX timestamping of last accessed, last modified, last status changed
                and created.
              </li>
<li class="listitem">
                File extent management and traversal.
              </li>
<li class="listitem">
                Explicitly documented filing system race guarantees.
              </li>
<li class="listitem">
                Interrogation of filing system characteristics, devices and mount
                points.
              </li>
<li class="listitem">
                Ten million item directories, or more. We have tested twenty five
                million item directories on NTFS and ext4 and performance was actually
                tolerable with under a second pause. Ten million item directories
                is plenty fast, and one million item directories you won't notice
                over a ten item directory. Note that your GUI file explorer will
                very likely hang on ten million item directories, indeed so do most
                command line tools.
              </li>
<li class="listitem">
                Exclusive lock files (manually operated support already there, async
                support coming in v1.4).
              </li>
<li class="listitem">
                File change monitoring (coming in v1.4).
              </li>
<li class="listitem">
                File byte range advisory locking (coming in v1.4).
              </li>
</ul></div>
        </li>
</ol></div>
<p>
      You'll probably note that these are POSIX file semantics. On Microsoft Windows,
      AFIO directly uses the NT kernel API and can therefore achieve reasonably accurate
      POSIX file semantics, at the cost of no support for DOS feature emulation like
      short names or case insensitivity or drive letters. Going directly to the NT
      kernel makes filing system performance on Windows both much faster and a close
      experience to coding for POSIX, this saves you time and money and produces
      a much more consistent experience for your users.
    </p>
<p>
      A surprising amount of production code out there is highly unreliable when
      used on a filing system experiencing rapid change, or even just a filing system
      mounted on a network. In many ways it is when your code needs to <span class="quote">&#8220;<span class="quote">grow
      up</span>&#8221;</span> from assuming a never changing static filesystem into a more realistic
      model is when you ought to reach AFIO which has hopefully abstracted away all
      those tedious platform specific and filing system specific quirks for you.
    </p>
<p>
      Using Boost.AFIO is centred around the <a class="link" href="reference/classes/async_file_io_dispatcher_base.html" title="async_file_io_dispatcher_base"><code class="computeroutput"><span class="identifier">async_file_io_dispatcher_base</span></code></a> abstract
      base class, whose underlying platform-specific implementation class is instantiated
      using the <a class="link" href="reference/functions/make_async_file_io_dispatcher.html" title="make_async_file_io_dispatcher"><code class="computeroutput"><span class="identifier">make_async_file_io_dispatcher</span><span class="special">()</span></code></a>
      factory function. Once you have a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span><span class="identifier">async_file_io_dispatcher_base</span><span class="special">&gt;</span></code>, you simply call its member functions to
      have the dispatcher schedule asynchronous work items for you, each returning
      a <a class="link" href="reference/structs/async_io_op.html" title="async_io_op"><code class="computeroutput"><span class="keyword">struct</span>
      <span class="identifier">async_io_op</span></code></a>. Note that dispatchers
      can be specialised with specific flags, so you could have one dispatcher which
      always fsyncs its files on close and another which does not. You can then schedule
      operations to the appropriate dispatcher. Currently you cannot chain operations
      across schedulers, this facility is expected to come with the coroutine support
      in v1.4.
    </p>
<p>
      All AFIO scheduling functions, or the convenience structures they take in,
      will take as a (sometimes optional) first parameter their precondition op.
      Only when that precondition has finished executing will its dependencies become
      scheduled for execution. This makes expanding out multiple ops from a single
      precondition easy, but what about reducing multiple ops down to a single precondition?
      For that, use <a class="link" href="reference/classes/async_file_io_dispatcher_base/barrier.html" title="barrier (batch)"><code class="computeroutput"><span class="identifier">async_file_io_dispatcher_base</span><span class="special">::</span><span class="identifier">barrier</span><span class="special">()</span></code></a>.
    </p>
<p>
      AFIO itself throws almost no exceptions apart from <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">invalid_argument</span></code>,
      though it can throw fatal exceptions when you're doing something unwise (and
      make sure to check the FAQ if you do see a fatal exception, it will explain
      what you're doing wrong). It does trap all operating system errors, reporting
      these as the appropriate <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">system_error</span></code>
      when code next gathers error state from that operation (usually using <code class="computeroutput"><span class="identifier">when_all</span><span class="special">()</span></code>
      or <code class="computeroutput"><span class="identifier">get</span><span class="special">()</span></code>).
      One can of course also receive exceptions thrown by anything AFIO calls (the
      STL, Boost etc). AFIO is thought to be exception safe, except when <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">bad_alloc</span></code>
      is thrown.
    </p>
<p>
      Note that from v1.4, AFIO will only throw exceptions for extraordinary events,
      and will instead directly return error codes for most errors.
    </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2013-2015 Niall Douglas
      and Paul Kirth<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="compilation.html"><img src="../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../afio.html"><img src="../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../afio.html"><img src="../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="quickstart/hello_world.html"><img src="../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
