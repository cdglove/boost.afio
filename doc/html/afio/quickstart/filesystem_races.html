<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Handling races on the filing system</title>
<link rel="stylesheet" href="../../../../libs/afio/doc/html/myboostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.76.1">
<link rel="home" href="../../afio.html" title="Chapter&#160;1.&#160;Boost.AFIO 1.30">
<link rel="up" href="../quickstart.html" title="Quick Start">
<link rel="prev" href="atomic_logging.html" title="Achieving atomicity on the filing system">
<link rel="next" href="so_what.html" title="What benefit does asynchronous file i/o bring me? A demonstration of AFIO's power">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../boost.png"></td>
<td align="center"><a href="../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="atomic_logging.html"><img src="../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../quickstart.html"><img src="../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../afio.html"><img src="../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="so_what.html"><img src="../../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="afio.quickstart.filesystem_races"></a><a class="link" href="filesystem_races.html" title="Handling races on the filing system">Handling races on the
      filing system</a>
</h3></div></div></div>
<p>
        Filing systems are a shared resource common to all processes on the system
        and sometimes the network, and are therefore as a globally shared resource
        inherently racy. Yet overwhelmingly programs, even often those written by
        world expert programmers, singularly assume the filing system to be a static,
        constant and unchanging place only modifiable by the current program, as
        indeed did until very recently the POSIX API standard which defines the common
        API for Linux, FreeBSD, Mac OS X and other Unices. When bug reports come
        in of data being lost, even very large professional corporations can make
        a real hash of testing that their <span class="quote">&#8220;<span class="quote">fix</span>&#8221;</span> isn't worse at losing
        data than the previous more naive implementation. This is because when you
        program against a mental model of a static, unchanging filesystem you will
        become inevitably surprised when it happens to change at exactly the wrong
        moment &#8212; which of course is a moment you can never replicate on your
        developer workstation, thus making finding and fixing these sorts of bug
        highly non-trivial.
      </p>
<p>
        In case you don't realise how much user data and productivity is lost each
        year to filing system races, just look up <span class="quote">&#8220;<span class="quote">corrupted Office file</span>&#8221;</span>
        on Google and weep. Even for us programmers, if you try keeping a Git repository
        on a Samba drive expect some interesting, and moreover quite strongly associated
        to specific combinations of client accessing the repo concurrently, object
        database corruption from time to time.
      </p>
<p>
        Well, there is some good news: AFIO makes maximum use of host OS filing system
        race safeguards, so if you write your code against AFIO and take note of
        the race guarantees section in each individual per-API reference documentation
        page, you should hopefully avoid any possibility of experiencing filing system
        races.
      </p>
<h5>
<a name="afio.quickstart.filesystem_races.h0"></a>
        <span><a name="afio.quickstart.filesystem_races.what_afio_provides_for_managing_"></a></span><a class="link" href="filesystem_races.html#afio.quickstart.filesystem_races.what_afio_provides_for_managing_">What
        AFIO provides for managing filing system raciness</a>
      </h5>
<p>
        Firstly, readers will probably be quite surprised to learn that the only
        operating system capable of providing completely race free filing system
        behaviour is Microsoft Windows, or rather the very well designed NT kernel
        API which AFIO uses directly. Linux provides robust file descriptor path
        discovery and the <code class="computeroutput"><span class="identifier">XXXat</span><span class="special">()</span></code>
        POSIX APIs, and with those AFIO can provide pretty good race condition safety
        on Linux up to the final directory in the path. Mac OS X provides an unfortunately
        quite broken file descriptor path discovery, and additionally does not provide
        the <code class="computeroutput"><span class="identifier">XXXat</span><span class="special">()</span></code>
        POSIX APIs and so AFIO cannot provide race protection, but can throw exceptions
        sometimes if it detects the filesystem has suddenly changed and you're about
        to delete the wrong file (you shouldn't rely on this, it's racy). FreeBSD
        provides the <code class="computeroutput"><span class="identifier">XXXat</span><span class="special">()</span></code>
        POSIX APIs, but its file descriptor path discovery only works correctly for
        directory not file handles due to a kernel bug (I've opened a feature request
        ticket for this at <a href="https://bugs.freebsd.org/bugzilla/show_bug.cgi?id=198570" target="_top">https://bugs.freebsd.org/bugzilla/show_bug.cgi?id=198570</a>)
        and therefore AFIO can provide only race condition safety for directories
        only on FreeBSD.
      </p>
<p>
        Additionally, working with the filing system in a race safe way on POSIX
        requires opening a file descriptor to the containing directory for every
        operation (some proprietary Linux extensions allow this to be avoided for
        some operations on newer Linux kernels). AFIO will keep a global cache of
        open file handles for containing directories on request using the <code class="computeroutput"><span class="identifier">file_flags</span><span class="special">::</span><span class="identifier">HoldParentOpen</span></code> flag which can be enabled
        per dispatcher or per individual file handle open, this very significantly
        reduces the cost of race condition safety on POSIX <span class="emphasis"><em>for file entries
        only</em></span> as directories ignore the <code class="computeroutput"><span class="identifier">file_flags</span><span class="special">::</span><span class="identifier">HoldParentOpen</span></code>
        flag, though at the cost of increased file descriptor usage, which has low
        hard limits especially on OS X which is why it is disabled by default. The
        alternative if you don't want AFIO to bother with race safety is to specify
        the <code class="computeroutput"><span class="identifier">file_flags</span><span class="special">::</span><span class="identifier">NoRaceProtection</span></code> flag per dispatcher or
        per individual file handle open, this causes AFIO to use the same maximum
        performance code paths as used before the v1.3 engine.
      </p>
<h5>
<a name="afio.quickstart.filesystem_races.h1"></a>
        <span><a name="afio.quickstart.filesystem_races.how_to_implement_filing_system_r"></a></span><a class="link" href="filesystem_races.html#afio.quickstart.filesystem_races.how_to_implement_filing_system_r">How
        to implement filing system race safety on AFIO</a>
      </h5>
<p>
        The essential rule for achieving maximum filing system race safety is to
        avoid using absolute paths where possible. If you want your code to also
        be safe on POSIX, you must additionally only assume race safety up to the
        final directory in a path &#8212; thereafter design your node to never behave
        racily within a single directory.
      </p>
<p>
        The core container type for specifying a location on the filing system to
        AFIO is <a class="link" href="../reference/structs/async_data_op_req/async_data_op_req.html" title="async_data_op_req"><code class="computeroutput"><span class="keyword">struct</span> <span class="identifier">async_data_op_req</span></code></a>
        which looks like this:
      </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">async_path_op_req</span>
<span class="special">{</span>
    <span class="keyword">bool</span> <span class="identifier">is_relative</span><span class="special">;</span>              <span class="comment">// Whether the precondition is also where this path begins.</span>
    <span class="identifier">afio</span><span class="special">::</span><span class="identifier">path</span> <span class="identifier">path</span><span class="special">;</span>               <span class="comment">// The filing system path to be used for this operation.</span>
    <span class="identifier">file_flags</span> <span class="identifier">flags</span><span class="special">;</span>              <span class="comment">// The flags to be used for this operation (note they can be overriden by flags passed during dispatcher construction).</span>
    <span class="identifier">async_io_op</span> <span class="identifier">precondition</span><span class="special">;</span>      <span class="comment">// An optional precondition for this operation.</span>
    <span class="identifier">async_path_op_req</span><span class="special">(</span><span class="identifier">T</span> <span class="special">&amp;&amp;);</span>       <span class="comment">// Converts T to a filesystem::path, makes it absolute, then converts to an afio::path</span>
    <span class="identifier">async_path_op_req</span><span class="special">(</span><span class="keyword">bool</span><span class="special">,</span> <span class="identifier">T</span> <span class="special">&amp;&amp;);</span> <span class="comment">// If the bool is true, converts T to an afio::path fragment. If false, same as above overload (i.e. make absolute).</span>
<span class="special">};</span>
</pre>
<p>
        For convenience, type markup is provided for the boolean taking constructor,
        these being <code class="computeroutput"><span class="identifier">async_path_op_req</span><span class="special">::</span><span class="identifier">relative</span></code>
        and <code class="computeroutput"><span class="identifier">async_path_op_req</span><span class="special">::</span><span class="identifier">absolute</span></code>.
      </p>
<p>
        If the path is relative, then the path of the precondition is used as the
        base from which the relative path fragment operates. On FreeBSD, Linux and
        Windows this base extension happens inside the kernel and so the current
        path of the precondition really doesn't matter &#8212; it could be changing
        a thousand times per second and it wouldn't matter. On OS X due to lack of
        the <code class="computeroutput"><span class="identifier">XXXat</span><span class="special">()</span></code>
        POSIX APIs the path of the precondition is fetched and the extension done
        by hand.
      </p>
<p>
        An AFIO extension allows you to specify a file as precondition. In this situation,
        if you specify an empty path then you mean the precondition itself which
        is very useful for deleting or renaming an open file handle. If you want
        a sibling file, this can be found via a path fragment starting with <code class="computeroutput"><span class="special">../</span></code>, though note that this necessarily is
        racy (AFIO opens the containing directory of the file, ensuring the directory
        contains an inode matching the file, and then uses that directory handle
        as a base &#8212; the race here being if the file relocates after matching
        its containing directory).
      </p>
<h5>
<a name="afio.quickstart.filesystem_races.h2"></a>
        <span><a name="afio.quickstart.filesystem_races.gotchas_specific_to_microsoft_wi"></a></span><a class="link" href="filesystem_races.html#afio.quickstart.filesystem_races.gotchas_specific_to_microsoft_wi">Gotchas
        specific to Microsoft Windows</a>
      </h5>
<p>
        Finally, there are some gotchas specific to Microsoft Windows:
      </p>
<p>
        1. You cannot rename a directory which has an open file handle in any process
        to any item anywhere within itself or its children.
      </p>
<p>
        2. You cannot rename to a destination which has an open file handle with
        DELETE permissions (<code class="computeroutput"><span class="identifier">file_flags</span><span class="special">::</span><span class="identifier">Write</span></code>)
        to itself or any of its parent directories in any process. You CAN do this
        from a source like this, but the destination cannot be like this (why is
        this? It is not documented anywhere in Microsoft's documentation, but if
        I had to guess, I'd suggest that the atomicity of the rename is implemented
        by taking an op lock on the destination, an op lock not granted if any handles
        exist which could change the path suddenly. I'm not sure if Microsoft are
        themselves aware of this limitation).
      </p>
<p>
        One might note that much of the utility of race protecting APIs is lost with
        these restrictions. However, note that one could emulate POSIX semantics
        by renaming out all the contents of a directory to be renamed to elsewhere,
        rename the directory, and then renaming the contents back in. Given the pathetic
        slowness of opening handles on Windows, this might seem impossibly inefficient,
        however NT provides a little known <code class="computeroutput"><span class="identifier">FILE_DELETE_CHILD</span></code>
        permission which gives you delete/rename permission on all the children and
        subchildren of a directory with just one handle open. I learned about this
        flag the hard way, by it breaking in many subtle ways AFIO's functioning
        on Windows when it was requested by default, something which took several
        days of head scratching to track down. AFIO doesn't currently do this trick
        of renaming out and back in on Windows, but might in the future after a lot
        more experimentation as to if it is viable and reliable without surprises.
      </p>
<p>
        On Windows opening a directory with write access requests rename/delete privileges,
        whereas on POSIX the write access request is ignored for directories as POSIX
        doesn't allow it anyway. This allows you to write identical code which works
        universally.
      </p>
<p>
        As an example of some programming AFIO safely on an extremely unstable filing
        system, below is the functional test which verifies AFIO for filing system
        race safety. As you will see, a worker thread is solely dedicated to renaming
        directories to unique names whilst the main thread creates files inside those
        constantly changing directories, and relinks them into another directory
        which is also constantly changing on POSIX, but is stable on Windows. This
        is iterated for a substantial period of time to verify that nothing goes
        wrong.
      </p>
<pre class="programlisting">  <span class="keyword">try</span>
  <span class="special">{</span>
    <span class="comment">// HoldParentOpen is actually ineffectual as renames zap the parent container, but it tests more code.</span>
    <span class="keyword">auto</span> <span class="identifier">dispatcher</span> <span class="special">=</span> <span class="identifier">make_async_file_io_dispatcher</span><span class="special">(</span><span class="identifier">process_threadpool</span><span class="special">(),</span> <span class="identifier">file_flags</span><span class="special">::</span><span class="identifier">HoldParentOpen</span><span class="special">);</span>
    <span class="keyword">auto</span> <span class="identifier">testdir</span> <span class="special">=</span> <span class="identifier">dispatcher</span><span class="special">-&gt;</span><span class="identifier">dir</span><span class="special">(</span><span class="identifier">async_path_op_req</span><span class="special">(</span><span class="string">"testdir"</span><span class="special">,</span> <span class="identifier">file_flags</span><span class="special">::</span><span class="identifier">Create</span><span class="special">));</span>
    <span class="identifier">async_io_op</span> <span class="identifier">dirh</span><span class="special">;</span>

    <span class="keyword">try</span>
    <span class="special">{</span>
      <span class="comment">// We can only reliably track directory renames on all platforms, so let's create 100 directories</span>
      <span class="comment">// which will be constantly renamed to something different by a worker thread</span>
      <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">async_path_op_req</span><span class="special">&gt;</span> <span class="identifier">dirreqs</span><span class="special">;</span>
      <span class="keyword">for</span><span class="special">(</span><span class="identifier">size_t</span> <span class="identifier">n</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="identifier">n</span> <span class="special">&lt;</span> <span class="identifier">ITEMS</span><span class="special">;</span> <span class="identifier">n</span><span class="special">++)</span>
        <span class="identifier">dirreqs</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">async_path_op_req</span><span class="special">::</span><span class="identifier">relative</span><span class="special">(</span><span class="identifier">testdir</span><span class="special">,</span> <span class="identifier">to_string</span><span class="special">(</span><span class="identifier">n</span><span class="special">),</span> <span class="identifier">file_flags</span><span class="special">::</span><span class="identifier">Create</span> <span class="special">|</span> <span class="identifier">file_flags</span><span class="special">::</span><span class="identifier">ReadWrite</span><span class="special">));</span>
      <span class="comment">// Windows needs write access to the directory to enable relinking, but opening a handle</span>
      <span class="comment">// with write access causes any renames into that directory to fail. So mark the first</span>
      <span class="comment">// directory which is always the destination for renames as non-writable</span>
      <span class="identifier">dirreqs</span><span class="special">.</span><span class="identifier">front</span><span class="special">().</span><span class="identifier">flags</span> <span class="special">=</span> <span class="identifier">file_flags</span><span class="special">::</span><span class="identifier">Create</span><span class="special">;</span>
      <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Creating "</span> <span class="special">&lt;&lt;</span> <span class="identifier">ITEMS</span> <span class="special">&lt;&lt;</span> <span class="string">" directories ..."</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
      <span class="keyword">auto</span> <span class="identifier">dirs</span> <span class="special">=</span> <span class="identifier">dispatcher</span><span class="special">-&gt;</span><span class="identifier">dir</span><span class="special">(</span><span class="identifier">dirreqs</span><span class="special">);</span>
      <span class="identifier">when_all</span><span class="special">(</span><span class="identifier">dirs</span><span class="special">).</span><span class="identifier">get</span><span class="special">();</span>
      <span class="identifier">dirh</span> <span class="special">=</span> <span class="identifier">dirs</span><span class="special">.</span><span class="identifier">front</span><span class="special">();</span>
      <span class="identifier">atomic</span><span class="special">&lt;</span><span class="keyword">bool</span><span class="special">&gt;</span> <span class="identifier">done</span><span class="special">(</span><span class="keyword">false</span><span class="special">);</span>
      <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Creating worker thread to constantly rename those "</span> <span class="special">&lt;&lt;</span> <span class="identifier">ITEMS</span> <span class="special">&lt;&lt;</span> <span class="string">" directories ..."</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
      <span class="identifier">thread</span> <span class="identifier">worker</span><span class="special">([&amp;</span><span class="identifier">done</span><span class="special">,</span> <span class="special">&amp;</span><span class="identifier">testdir</span><span class="special">,</span> <span class="special">&amp;</span><span class="identifier">dirs</span><span class="special">]</span>
                    <span class="special">{</span>
                      <span class="keyword">for</span><span class="special">(</span><span class="identifier">size_t</span> <span class="identifier">number</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="special">!</span><span class="identifier">done</span><span class="special">;</span> <span class="identifier">number</span><span class="special">++)</span>
                      <span class="special">{</span>
                        <span class="keyword">try</span>
                        <span class="special">{</span>
<span class="preprocessor">#ifdef</span> <span class="identifier">WIN32</span>
                          <span class="keyword">for</span><span class="special">(</span><span class="identifier">size_t</span> <span class="identifier">n</span> <span class="special">=</span> <span class="number">1</span><span class="special">;</span> <span class="identifier">n</span> <span class="special">&lt;</span> <span class="identifier">ITEMS</span><span class="special">;</span> <span class="identifier">n</span><span class="special">++)</span>
<span class="preprocessor">#else</span>
                          <span class="keyword">for</span><span class="special">(</span><span class="identifier">size_t</span> <span class="identifier">n</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="identifier">n</span> <span class="special">&lt;</span> <span class="identifier">ITEMS</span><span class="special">;</span> <span class="identifier">n</span><span class="special">++)</span>
<span class="preprocessor">#endif</span>
                          <span class="special">{</span>
                            <span class="identifier">async_path_op_req</span><span class="special">::</span><span class="identifier">relative</span> <span class="identifier">req</span><span class="special">(</span><span class="identifier">testdir</span><span class="special">,</span> <span class="identifier">to_string</span><span class="special">(</span><span class="identifier">number</span><span class="special">)</span> <span class="special">+</span> <span class="string">"_"</span> <span class="special">+</span> <span class="identifier">to_string</span><span class="special">(</span><span class="identifier">n</span><span class="special">));</span>
                            <span class="comment">// std::cout &lt;&lt; "Renaming " &lt;&lt; dirs[n].get()-&gt;path(true) &lt;&lt; " ..." &lt;&lt; std::endl;</span>
                            <span class="keyword">try</span>
                            <span class="special">{</span>
                              <span class="identifier">dirs</span><span class="special">[</span><span class="identifier">n</span><span class="special">].</span><span class="identifier">get</span><span class="special">()-&gt;</span><span class="identifier">atomic_relink</span><span class="special">(</span><span class="identifier">req</span><span class="special">);</span>
                            <span class="special">}</span>
<span class="preprocessor">#ifdef</span> <span class="identifier">WIN32</span>
                            <span class="keyword">catch</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">system_error</span> <span class="special">&amp;</span> <span class="comment">/*e*/</span><span class="special">)</span>
                            <span class="special">{</span>
                              <span class="comment">// Windows does not permit renaming a directory containing open file handles</span>
                              <span class="comment">// std::cout &lt;&lt; "NOTE: Failed to rename directory " &lt;&lt; dirs[n]-&gt;path() &lt;&lt; " due to " &lt;&lt; e.what() &lt;&lt; ", this is usual on Windows." &lt;&lt; std::endl;</span>
                            <span class="special">}</span>
<span class="preprocessor">#else</span>
                            <span class="keyword">catch</span><span class="special">(...)</span>
                            <span class="special">{</span>
                              <span class="keyword">throw</span><span class="special">;</span>
                            <span class="special">}</span>
<span class="preprocessor">#endif</span>
                          <span class="special">}</span>
                          <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Worker relinked all dirs to "</span> <span class="special">&lt;&lt;</span> <span class="identifier">number</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
                        <span class="special">}</span>
                        <span class="keyword">catch</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">system_error</span> <span class="special">&amp;</span><span class="identifier">e</span><span class="special">)</span>
                        <span class="special">{</span>
                          <span class="identifier">std</span><span class="special">::</span><span class="identifier">cerr</span> <span class="special">&lt;&lt;</span> <span class="string">"ERROR: worker thread exits via system_error code "</span> <span class="special">&lt;&lt;</span> <span class="identifier">e</span><span class="special">.</span><span class="identifier">code</span><span class="special">().</span><span class="identifier">value</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">"("</span> <span class="special">&lt;&lt;</span> <span class="identifier">e</span><span class="special">.</span><span class="identifier">what</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">")"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
                          <span class="identifier">BOOST_CHECK</span><span class="special">(</span><span class="keyword">false</span><span class="special">);</span>
                        <span class="special">}</span>
                        <span class="keyword">catch</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">exception</span> <span class="special">&amp;</span><span class="identifier">e</span><span class="special">)</span>
                        <span class="special">{</span>
                          <span class="identifier">std</span><span class="special">::</span><span class="identifier">cerr</span> <span class="special">&lt;&lt;</span> <span class="string">"ERROR: worker thread exits via exception ("</span> <span class="special">&lt;&lt;</span> <span class="identifier">e</span><span class="special">.</span><span class="identifier">what</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">")"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
                          <span class="identifier">BOOST_CHECK</span><span class="special">(</span><span class="keyword">false</span><span class="special">);</span>
                        <span class="special">}</span>
                        <span class="keyword">catch</span><span class="special">(...)</span>
                        <span class="special">{</span>
                          <span class="identifier">std</span><span class="special">::</span><span class="identifier">cerr</span> <span class="special">&lt;&lt;</span> <span class="string">"ERROR: worker thread exits via unknown exception"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
                          <span class="identifier">BOOST_CHECK</span><span class="special">(</span><span class="keyword">false</span><span class="special">);</span>
                        <span class="special">}</span>
                      <span class="special">}</span>
                    <span class="special">});</span>
      <span class="keyword">auto</span> <span class="identifier">unworker</span> <span class="special">=</span> <span class="identifier">detail</span><span class="special">::</span><span class="identifier">Undoer</span><span class="special">([&amp;</span><span class="identifier">done</span><span class="special">,</span> <span class="special">&amp;</span><span class="identifier">worker</span><span class="special">]</span>
                                     <span class="special">{</span>
                                       <span class="identifier">done</span> <span class="special">=</span> <span class="keyword">true</span><span class="special">;</span>
                                       <span class="identifier">worker</span><span class="special">.</span><span class="identifier">join</span><span class="special">();</span>
                                     <span class="special">});</span>

      <span class="comment">// Create some files inside the changing directories and rename them across changing directories</span>
      <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">async_io_op</span><span class="special">&gt;</span> <span class="identifier">newfiles</span><span class="special">;</span>
      <span class="keyword">for</span><span class="special">(</span><span class="identifier">size_t</span> <span class="identifier">n</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="identifier">n</span> <span class="special">&lt;</span> <span class="identifier">ITEMS</span><span class="special">;</span> <span class="identifier">n</span><span class="special">++)</span>
      <span class="special">{</span>
        <span class="identifier">dirreqs</span><span class="special">[</span><span class="identifier">n</span><span class="special">].</span><span class="identifier">precondition</span> <span class="special">=</span> <span class="identifier">dirs</span><span class="special">[</span><span class="identifier">n</span><span class="special">];</span>
        <span class="identifier">dirreqs</span><span class="special">[</span><span class="identifier">n</span><span class="special">].</span><span class="identifier">flags</span> <span class="special">=</span> <span class="identifier">file_flags</span><span class="special">::</span><span class="identifier">CreateOnlyIfNotExist</span> <span class="special">|</span> <span class="identifier">file_flags</span><span class="special">::</span><span class="identifier">ReadWrite</span><span class="special">;</span>
      <span class="special">}</span>
      <span class="keyword">for</span><span class="special">(</span><span class="identifier">size_t</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">&lt;</span> <span class="identifier">ITERATIONS</span><span class="special">;</span> <span class="identifier">i</span><span class="special">++)</span>
      <span class="special">{</span>
        <span class="keyword">if</span><span class="special">(!</span><span class="identifier">newfiles</span><span class="special">.</span><span class="identifier">empty</span><span class="special">())</span>
          <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Iteration "</span> <span class="special">&lt;&lt;</span> <span class="identifier">i</span> <span class="special">&lt;&lt;</span> <span class="string">": Renaming "</span> <span class="special">&lt;&lt;</span> <span class="identifier">ITEMS</span> <span class="special">&lt;&lt;</span> <span class="string">" files and directories inside the "</span> <span class="special">&lt;&lt;</span> <span class="identifier">ITEMS</span> <span class="special">&lt;&lt;</span> <span class="string">" constantly changing directories ..."</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
        <span class="keyword">for</span><span class="special">(</span><span class="identifier">size_t</span> <span class="identifier">n</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="identifier">n</span> <span class="special">&lt;</span> <span class="identifier">ITEMS</span><span class="special">;</span> <span class="identifier">n</span><span class="special">++)</span>
        <span class="special">{</span>
          <span class="keyword">if</span><span class="special">(!</span><span class="identifier">newfiles</span><span class="special">.</span><span class="identifier">empty</span><span class="special">())</span>
          <span class="special">{</span>
            <span class="comment">// Relink previous new file into first directory</span>
            <span class="comment">// std::cout &lt;&lt; "Renaming " &lt;&lt; newfiles[n].get()-&gt;path() &lt;&lt; std::endl;</span>
            <span class="identifier">newfiles</span><span class="special">[</span><span class="identifier">n</span><span class="special">].</span><span class="identifier">get</span><span class="special">()-&gt;</span><span class="identifier">atomic_relink</span><span class="special">(</span><span class="identifier">async_path_op_req</span><span class="special">::</span><span class="identifier">relative</span><span class="special">(</span><span class="identifier">dirh</span><span class="special">,</span> <span class="identifier">to_string</span><span class="special">(</span><span class="identifier">n</span><span class="special">)</span> <span class="special">+</span> <span class="string">"_"</span> <span class="special">+</span> <span class="identifier">to_string</span><span class="special">(</span><span class="identifier">i</span><span class="special">)));</span>
            <span class="comment">// Note that on FreeBSD if this is a file its path would be now be incorrect and moreover lost due to lack of</span>
            <span class="comment">// path enumeration support for files. As we throw away the handle, this doesn't show up here.</span>

            <span class="comment">// Have the file creation depend on the previous file creation</span>
            <span class="identifier">dirreqs</span><span class="special">[</span><span class="identifier">n</span><span class="special">].</span><span class="identifier">precondition</span> <span class="special">=</span> <span class="identifier">dispatcher</span><span class="special">-&gt;</span><span class="identifier">depends</span><span class="special">(</span><span class="identifier">newfiles</span><span class="special">[</span><span class="identifier">n</span><span class="special">],</span> <span class="identifier">dirs</span><span class="special">[</span><span class="identifier">n</span><span class="special">]);</span>
          <span class="special">}</span>
          <span class="identifier">dirreqs</span><span class="special">[</span><span class="identifier">n</span><span class="special">].</span><span class="identifier">path</span> <span class="special">=</span> <span class="identifier">to_string</span><span class="special">(</span><span class="identifier">i</span><span class="special">);</span>
        <span class="special">}</span>
        <span class="comment">// Split into two</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">async_path_op_req</span><span class="special">&gt;</span> <span class="identifier">front</span><span class="special">(</span><span class="identifier">dirreqs</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">dirreqs</span><span class="special">.</span><span class="identifier">begin</span><span class="special">()</span> <span class="special">+</span> <span class="identifier">ITEMS</span> <span class="special">/</span> <span class="number">2</span><span class="special">),</span> <span class="identifier">back</span><span class="special">(</span><span class="identifier">dirreqs</span><span class="special">.</span><span class="identifier">begin</span><span class="special">()</span> <span class="special">+</span> <span class="identifier">ITEMS</span> <span class="special">/</span> <span class="number">2</span><span class="special">,</span> <span class="identifier">dirreqs</span><span class="special">.</span><span class="identifier">end</span><span class="special">());</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Iteration "</span> <span class="special">&lt;&lt;</span> <span class="identifier">i</span> <span class="special">&lt;&lt;</span> <span class="string">": Creating "</span> <span class="special">&lt;&lt;</span> <span class="identifier">ITEMS</span> <span class="special">&lt;&lt;</span> <span class="string">" files and directories inside the "</span> <span class="special">&lt;&lt;</span> <span class="identifier">ITEMS</span> <span class="special">&lt;&lt;</span> <span class="string">" constantly changing directories ..."</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="preprocessor">#ifdef</span> <span class="identifier">__FreeBSD__</span>  <span class="comment">// FreeBSD can only track directories not files when their parent directories change</span>
        <span class="identifier">newfiles</span> <span class="special">=</span> <span class="identifier">dispatcher</span><span class="special">-&gt;</span><span class="identifier">dir</span><span class="special">(</span><span class="identifier">front</span><span class="special">);</span>
<span class="preprocessor">#else</span>
        <span class="identifier">newfiles</span> <span class="special">=</span> <span class="identifier">dispatcher</span><span class="special">-&gt;</span><span class="identifier">file</span><span class="special">(</span><span class="identifier">front</span><span class="special">);</span>
<span class="preprocessor">#endif</span>
        <span class="keyword">auto</span> <span class="identifier">newfiles2</span> <span class="special">=</span> <span class="identifier">dispatcher</span><span class="special">-&gt;</span><span class="identifier">dir</span><span class="special">(</span><span class="identifier">back</span><span class="special">);</span>
        <span class="identifier">newfiles</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span><span class="identifier">newfiles</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">make_move_iterator</span><span class="special">(</span><span class="identifier">newfiles2</span><span class="special">.</span><span class="identifier">begin</span><span class="special">()),</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">make_move_iterator</span><span class="special">(</span><span class="identifier">newfiles2</span><span class="special">.</span><span class="identifier">end</span><span class="special">()));</span>

        <span class="comment">// Pace the scheduling, else we slow things down a ton. Also retrieve and throw any errors.</span>
        <span class="identifier">when_all</span><span class="special">(</span><span class="identifier">newfiles</span><span class="special">).</span><span class="identifier">get</span><span class="special">();</span>
      <span class="special">}</span>
      <span class="comment">// Wait around for all that to process</span>
      <span class="keyword">do</span>
      <span class="special">{</span>
        <span class="identifier">this_thread</span><span class="special">::</span><span class="identifier">sleep_for</span><span class="special">(</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">seconds</span><span class="special">(</span><span class="number">1</span><span class="special">));</span>
      <span class="special">}</span> <span class="keyword">while</span><span class="special">(</span><span class="identifier">dispatcher</span><span class="special">-&gt;</span><span class="identifier">wait_queue_depth</span><span class="special">());</span>
      <span class="comment">// Close all handles opened during this context except for dirh</span>
    <span class="special">}</span>
    <span class="keyword">catch</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">system_error</span> <span class="special">&amp;</span><span class="identifier">e</span><span class="special">)</span>
    <span class="special">{</span>
      <span class="identifier">std</span><span class="special">::</span><span class="identifier">cerr</span> <span class="special">&lt;&lt;</span> <span class="string">"ERROR: test exits via system_error code "</span> <span class="special">&lt;&lt;</span> <span class="identifier">e</span><span class="special">.</span><span class="identifier">code</span><span class="special">().</span><span class="identifier">value</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">"("</span> <span class="special">&lt;&lt;</span> <span class="identifier">e</span><span class="special">.</span><span class="identifier">what</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">")"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
      <span class="identifier">BOOST_REQUIRE</span><span class="special">(</span><span class="keyword">false</span><span class="special">);</span>
    <span class="special">}</span>
    <span class="keyword">catch</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">exception</span> <span class="special">&amp;</span><span class="identifier">e</span><span class="special">)</span>
    <span class="special">{</span>
      <span class="identifier">std</span><span class="special">::</span><span class="identifier">cerr</span> <span class="special">&lt;&lt;</span> <span class="string">"ERROR: test exits via exception ("</span> <span class="special">&lt;&lt;</span> <span class="identifier">e</span><span class="special">.</span><span class="identifier">what</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">")"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
      <span class="identifier">BOOST_REQUIRE</span><span class="special">(</span><span class="keyword">false</span><span class="special">);</span>
    <span class="special">}</span>
    <span class="keyword">catch</span><span class="special">(...)</span>
    <span class="special">{</span>
      <span class="identifier">std</span><span class="special">::</span><span class="identifier">cerr</span> <span class="special">&lt;&lt;</span> <span class="string">"ERROR: test exits via unknown exception"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
      <span class="identifier">BOOST_REQUIRE</span><span class="special">(</span><span class="keyword">false</span><span class="special">);</span>
    <span class="special">}</span>

    <span class="comment">// Check that everything is as it ought to be</span>
    <span class="keyword">auto</span> <span class="identifier">_contents</span> <span class="special">=</span> <span class="identifier">dispatcher</span><span class="special">-&gt;</span><span class="identifier">enumerate</span><span class="special">(</span><span class="identifier">async_enumerate_op_req</span><span class="special">(</span><span class="identifier">dirh</span><span class="special">,</span> <span class="identifier">metadata_flags</span><span class="special">::</span><span class="identifier">All</span><span class="special">,</span> <span class="number">10</span> <span class="special">*</span> <span class="identifier">ITEMS</span> <span class="special">*</span> <span class="identifier">ITERATIONS</span><span class="special">)).</span><span class="identifier">first</span><span class="special">.</span><span class="identifier">get</span><span class="special">().</span><span class="identifier">first</span><span class="special">;</span>
    <span class="identifier">testdir</span> <span class="special">=</span> <span class="identifier">async_io_op</span><span class="special">();</span>  <span class="comment">// Kick out AFIO now so NTFS has itself cleaned up by the end of the checks</span>
    <span class="identifier">dirh</span> <span class="special">=</span> <span class="identifier">async_io_op</span><span class="special">();</span>
    <span class="identifier">dispatcher</span><span class="special">.</span><span class="identifier">reset</span><span class="special">();</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Checking that we successfully renamed "</span> <span class="special">&lt;&lt;</span> <span class="special">(</span><span class="identifier">ITEMS</span> <span class="special">*</span> <span class="special">(</span><span class="identifier">ITERATIONS</span> <span class="special">-</span> <span class="number">1</span><span class="special">)</span> <span class="special">+</span> <span class="number">1</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="string">" items into the same directory ..."</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
    <span class="identifier">BOOST_CHECK</span><span class="special">(</span><span class="identifier">_contents</span><span class="special">.</span><span class="identifier">size</span><span class="special">()</span> <span class="special">==</span> <span class="special">(</span><span class="identifier">ITEMS</span> <span class="special">*</span> <span class="special">(</span><span class="identifier">ITERATIONS</span> <span class="special">-</span> <span class="number">1</span><span class="special">)</span> <span class="special">+</span> <span class="number">1</span><span class="special">));</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">set</span><span class="special">&lt;</span><span class="identifier">BOOST_AFIO_V1_NAMESPACE</span><span class="special">::</span><span class="identifier">filesystem</span><span class="special">::</span><span class="identifier">path</span><span class="special">&gt;</span> <span class="identifier">contents</span><span class="special">;</span>
    <span class="keyword">for</span><span class="special">(</span><span class="keyword">auto</span> <span class="special">&amp;</span><span class="identifier">i</span> <span class="special">:</span> <span class="identifier">_contents</span><span class="special">)</span>
      <span class="identifier">contents</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span><span class="identifier">i</span><span class="special">.</span><span class="identifier">name</span><span class="special">());</span>
    <span class="identifier">BOOST_CHECK</span><span class="special">(</span><span class="identifier">contents</span><span class="special">.</span><span class="identifier">size</span><span class="special">()</span> <span class="special">==</span> <span class="special">(</span><span class="identifier">ITEMS</span> <span class="special">*</span> <span class="special">(</span><span class="identifier">ITERATIONS</span> <span class="special">-</span> <span class="number">1</span><span class="special">)</span> <span class="special">+</span> <span class="number">1</span><span class="special">));</span>
    <span class="keyword">for</span><span class="special">(</span><span class="identifier">size_t</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">1</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">&lt;</span> <span class="identifier">ITERATIONS</span><span class="special">;</span> <span class="identifier">i</span><span class="special">++)</span>
    <span class="special">{</span>
      <span class="keyword">for</span><span class="special">(</span><span class="identifier">size_t</span> <span class="identifier">n</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="identifier">n</span> <span class="special">&lt;</span> <span class="identifier">ITEMS</span><span class="special">;</span> <span class="identifier">n</span><span class="special">++)</span>
      <span class="special">{</span>
        <span class="keyword">if</span><span class="special">(</span><span class="identifier">contents</span><span class="special">.</span><span class="identifier">count</span><span class="special">(</span><span class="identifier">to_string</span><span class="special">(</span><span class="identifier">n</span><span class="special">)</span> <span class="special">+</span> <span class="string">"_"</span> <span class="special">+</span> <span class="identifier">to_string</span><span class="special">(</span><span class="identifier">i</span><span class="special">))</span> <span class="special">==</span> <span class="number">0</span><span class="special">)</span>
          <span class="identifier">std</span><span class="special">::</span><span class="identifier">cerr</span> <span class="special">&lt;&lt;</span> <span class="identifier">to_string</span><span class="special">(</span><span class="identifier">n</span><span class="special">)</span> <span class="special">+</span> <span class="string">"_"</span> <span class="special">+</span> <span class="identifier">to_string</span><span class="special">(</span><span class="identifier">i</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
        <span class="identifier">BOOST_CHECK</span><span class="special">(</span><span class="identifier">contents</span><span class="special">.</span><span class="identifier">count</span><span class="special">(</span><span class="identifier">to_string</span><span class="special">(</span><span class="identifier">n</span><span class="special">)</span> <span class="special">+</span> <span class="string">"_"</span> <span class="special">+</span> <span class="identifier">to_string</span><span class="special">(</span><span class="identifier">i</span><span class="special">))</span> <span class="special">&gt;</span> <span class="number">0</span><span class="special">);</span>
      <span class="special">}</span>
    <span class="special">}</span>
    <span class="identifier">filesystem</span><span class="special">::</span><span class="identifier">remove_all</span><span class="special">(</span><span class="string">"testdir"</span><span class="special">);</span>
  <span class="special">}</span>
  <span class="keyword">catch</span><span class="special">(...)</span>
  <span class="special">{</span>
    <span class="identifier">filesystem</span><span class="special">::</span><span class="identifier">remove_all</span><span class="special">(</span><span class="string">"testdir"</span><span class="special">);</span>
    <span class="keyword">throw</span><span class="special">;</span>
  <span class="special">}</span>
</pre>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2013-2015 Niall Douglas
      and Paul Kirth<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="atomic_logging.html"><img src="../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../quickstart.html"><img src="../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../afio.html"><img src="../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="so_what.html"><img src="../../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
